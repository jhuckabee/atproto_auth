Project Structure:
├── .git
├── .github
├── .idea
├── CHANGELOG.md
├── Gemfile
├── LICENSE.txt
├── README.md
├── Rakefile
├── atproto_auth.gemspec
├── bin
│   ├── console
│   ├── setup
│   └── snapshot
├── examples
│   └── confidential_client
│       ├── Gemfile
│       ├── README.md
│       ├── app.rb
│       ├── config
│       │   ├── client-metadata.example.json
│       │   └── client-metadata.json
│       ├── config.ru
│       ├── public
│       │   ├── client-metadata.json
│       │   └── styles.css
│       ├── screenshots
│       │   ├── screenshot-1-sign-in.png
│       │   └── screenshot-2-success.png
│       ├── scripts
│       │   └── generate_keys.rb
│       └── views
│           ├── authorized.erb
│           ├── index.erb
│           └── layout.erb
├── lib
│   ├── atproto_auth
│   │   ├── client.rb
│   │   ├── client_metadata.rb
│   │   ├── configuration.rb
│   │   ├── dpop
│   │   │   ├── client.rb
│   │   │   ├── key_manager.rb
│   │   │   ├── nonce_manager.rb
│   │   │   └── proof_generator.rb
│   │   ├── encryption.rb
│   │   ├── errors.rb
│   │   ├── http_client.rb
│   │   ├── identity
│   │   │   ├── document.rb
│   │   │   └── resolver.rb
│   │   ├── identity.rb
│   │   ├── par
│   │   │   ├── client.rb
│   │   │   ├── client_assertion.rb
│   │   │   ├── request.rb
│   │   │   └── response.rb
│   │   ├── par.rb
│   │   ├── pkce.rb
│   │   ├── serialization
│   │   │   ├── base.rb
│   │   │   ├── dpop_key.rb
│   │   │   ├── session.rb
│   │   │   ├── stored_nonce.rb
│   │   │   └── token_set.rb
│   │   ├── server_metadata
│   │   │   ├── authorization_server.rb
│   │   │   ├── origin_url.rb
│   │   │   └── resource_server.rb
│   │   ├── server_metadata.rb
│   │   ├── state
│   │   │   ├── session.rb
│   │   │   ├── session_manager.rb
│   │   │   └── token_set.rb
│   │   ├── state.rb
│   │   ├── storage
│   │   │   ├── interface.rb
│   │   │   ├── key_builder.rb
│   │   │   ├── memory.rb
│   │   │   └── redis.rb
│   │   ├── token
│   │   │   └── refresh.rb
│   │   └── version.rb
│   └── atproto_auth.rb
├── pkg
├── sig
│   ├── atproto_auth
│   │   ├── client_metadata.rbs
│   │   ├── dpop
│   │   │   ├── client.rbs
│   │   │   ├── key_manager.rbs
│   │   │   ├── nonce_manager.rbs
│   │   │   └── proof_generator.rbs
│   │   ├── http_client.rbs
│   │   ├── identity
│   │   │   ├── document.rbs
│   │   │   └── resolver.rbs
│   │   ├── par
│   │   │   ├── client.rbs
│   │   │   ├── request.rbs
│   │   │   └── response.rbs
│   │   ├── pkce.rbs
│   │   ├── server_metadata
│   │   │   ├── authorization_server.rbs
│   │   │   ├── origin_url.rbs
│   │   │   └── resource_server.rbs
│   │   ├── state
│   │   │   ├── session.rbs
│   │   │   ├── session_manager.rbs
│   │   │   └── token_set.rbs
│   │   └── version.rbs
│   └── atproto_auth.rbs
└── test
    ├── atproto_auth
    │   ├── client_metadata_test.rb
    │   ├── configuration_test.rb
    │   ├── dpop
    │   │   ├── client_test.rb
    │   │   ├── key_manager_test.rb
    │   │   ├── nonce_manager_test.rb
    │   │   └── proof_generator_test.rb
    │   ├── encryption_test.rb
    │   ├── http_client_test.rb
    │   ├── identity
    │   │   ├── document_test.rb
    │   │   └── resolver_test.rb
    │   ├── par
    │   │   ├── client_assertion_test.rb
    │   │   ├── client_test.rb
    │   │   ├── request_test.rb
    │   │   └── response_test.rb
    │   ├── pkce_test.rb
    │   ├── serialization
    │   │   ├── base_test.rb
    │   │   ├── dpop_key_test.rb
    │   │   ├── session_test.rb
    │   │   ├── stored_nonce_test.rb
    │   │   └── token_set_test.rb
    │   ├── server_metadata
    │   │   ├── authorization_server_test.rb
    │   │   ├── origin_url_test.rb
    │   │   └── resource_server_test.rb
    │   ├── state
    │   │   ├── session_manager_test.rb
    │   │   ├── session_test.rb
    │   │   └── token_set_test.rb
    │   ├── storage
    │   │   ├── key_builder_test.rb
    │   │   ├── memory_test.rb
    │   │   ├── redis_test.rb
    │   │   └── storage_examples.rb
    │   └── token
    │       └── refresh_test.rb
    ├── atproto_auth_test.rb
    └── test_helper.rb


CHANGELOG.md:
## [Unreleased]

## [0.0.1] - 2024-12-05

- Initial release
-----

Gemfile:
# frozen_string_literal: true

source "https://rubygems.org"

# Specify your gem's dependencies in atproto_auth.gemspec
gemspec

gem "minitest", "~> 5.25"
gem "minitest-reporters", "~> 1.7"
gem "mocha", "~> 2.6"
gem "mutex_m", "~> 0.3"
gem "rake", "~> 13.0"
gem "rbs", "~> 3.6"
gem "rubocop", "~> 1.21"
gem "webmock", "~> 3.24"
-----

LICENSE.txt:
The MIT License (MIT)

Copyright (c) 2024 Josh Huckabee

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
-----

README.md:
# AtprotoAuth

[![Gem Version](https://badge.fury.io/rb/atproto_auth.svg)](https://badge.fury.io/rb/atproto_auth)
[![Ruby Style Guide](https://img.shields.io/badge/code_style-standard-brightgreen.svg)](https://github.com/testdouble/standard)
[![Documentation](https://img.shields.io/badge/docs-rdoc-blue.svg)](https://www.rubydoc.info/gems/atproto_auth)

A Ruby implementation of the [AT Protocol OAuth specification](https://docs.bsky.app/docs/advanced-guides/oauth-client). This library provides comprehensive support for both client and server-side implementations, with built-in security features including DPoP (Demonstrating Proof of Possession), PAR (Pushed Authorization Requests), and dynamic client registration.

## Features

- Complete AT Protocol OAuth 2.0 implementation
- Secure by default with mandatory DPoP and PKCE
- Support for confidential (backend) and public clients
- Thread-safe session and token management
- Comprehensive identity resolution and verification
- Automatic token refresh and session management
- Robust error handling and recovery mechanisms

## Installation

Add this line to your application's Gemfile:

```ruby
gem 'atproto_auth'
```

And then execute:

```sh
bundle install
```

Or install it yourself as:

```sh
gem install atproto_auth
```

## Requirements

- Ruby 3.0 or higher
- OpenSSL support
- For confidential clients: HTTPS-capable domain for client metadata hosting

## Basic Usage

### Configuration

```ruby
require 'atproto_auth'

AtprotoAuth.configure do |config|
  # Configure HTTP client settings
  config.http_client = AtprotoAuth::HttpClient.new(
    timeout: 10,
    verify_ssl: true
  )

  # Set token lifetimes
  config.default_token_lifetime = 300 # 5 minutes
  config.dpop_nonce_lifetime = 300  # 5 minutes
end
```

### Confidential Client Example

Here's a basic example of using the library in a confidential client application:

```ruby
# Initialize client with metadata
client = AtprotoAuth::Client.new(
  client_id: "https://app.example.com/client-metadata.json",
  redirect_uri: "https://app.example.com/callback",
  metadata: {
    # Your client metadata...
  }
)

# Start authorization flow
auth = client.authorize(
  handle: "user.bsky.social",
  scope: "atproto"
)

# Use auth[:url] to redirect user

# Handle callback
tokens = client.handle_callback(
  code: params[:code],
  state: params[:state],
  iss: params[:iss]
)

# Make authenticated requests
headers = client.auth_headers(
  session_id: tokens[:session_id],
  method: "GET",
  url: "https://api.example.com/resource"
)
```

For a complete working example of a confidential client implementation, check out the example application in `examples/confidential_client/`. This Sinatra-based web application demonstrates:
- Complete OAuth flow implementation
- Session management
- DPoP token binding
- Making authenticated API requests
- Proper error handling
- Key generation and management

See `examples/confidential_client/README.md` for setup instructions and implementation details.

### Public Client Example

```ruby
client = AtprotoAuth::Client.new(
  client_id: "https://app.example.com/client-metadata.json",
  redirect_uri: "https://app.example.com/callback"
)

# Browser will open authorization URL
auth = client.authorize(
  handle: "user.bsky.social",
  scope: "atproto"
)

# After callback, exchange code for tokens
tokens = client.handle_callback(
  code: params[:code],
  state: params[:state],
  iss: params[:iss]
)
```

## Features In Detail

### Identity Resolution

The library handles the complete AT Protocol identity resolution flow:

- Handle to DID resolution (DNS-based or HTTP fallback)
- DID document fetching and validation
- PDS (Personal Data Server) location verification
- Bidirectional handle verification
- Authorization server binding verification

### Token & Session Management

Comprehensive token lifecycle management:

- Secure token storage with encryption
- Automatic token refresh
- DPoP proof generation and binding
- Session state tracking
- Cleanup of expired sessions

### Security Features

Built-in security best practices:

- Mandatory PKCE for all flows
- DPoP token binding
- Constant-time token comparisons
- Thread-safe state management
- Protection against SSRF attacks
- Secure token storage

## Development

After checking out the repo, run `bin/setup` to install dependencies. Then, run `rake test` to run the tests. You can also run `bin/console` for an interactive prompt that will allow you to experiment.

To install this gem onto your local machine, run `bundle exec rake install`. To release a new version, update the version number in `version.rb`, and then run `bundle exec rake release`, which will create a git tag for the version, push git commits and the created tag, and push the `.gem` file to [rubygems.org](https://rubygems.org).

## Contributing

Bug reports and pull requests are welcome on GitHub at https://github.com/jhuckabee/atproto_auth.

## License

The gem is available as open source under the terms of the [MIT License](https://opensource.org/licenses/MIT).
-----

Rakefile:
# frozen_string_literal: true

require "bundler/gem_tasks"
require "rake/testtask"

Rake::TestTask.new(:test) do |t|
  t.libs << "test"
  t.libs << "lib"
  t.test_files = FileList["test/**/*_test.rb"]
end

require "rubocop/rake_task"

RuboCop::RakeTask.new

task default: %i[test rubocop]
-----

atproto_auth.gemspec:
# frozen_string_literal: true

require_relative "lib/atproto_auth/version"

Gem::Specification.new do |spec|
  spec.name = "atproto_auth"
  spec.version = AtprotoAuth::VERSION
  spec.authors = ["Josh Huckabee"]
  spec.email = ["mail@joshhuckabee.com"]

  spec.summary = "Ruby implementation of the AT Protocol OAuth specification"
  spec.description = "A Ruby library for implementing AT Protocol OAuth flows, including DPoP, PAR, and dynamic client registration. Supports both client and server-side implementations with comprehensive security features." # rubocop:disable Layout/LineLength
  spec.homepage = "https://github.com/jhuckabee/atproto_auth"
  spec.license = "MIT"
  spec.required_ruby_version = ">= 3.0.0"

  spec.metadata["homepage_uri"] = spec.homepage
  spec.metadata["source_code_uri"] = "https://github.com/jhuckabee/atproto_auth"
  spec.metadata["changelog_uri"] = "https://github.com/jhuckabee/atproto_auth/blob/main/CHANGELOG.md"
  spec.metadata["rubygems_mfa_required"] = "true"

  gemspec = File.basename(__FILE__)
  spec.files = IO.popen(%w[git ls-files -z], chdir: __dir__, err: IO::NULL) do |ls|
    ls.readlines("\x0", chomp: true).reject do |f|
      (f == gemspec) ||
        f.start_with?(*%w[bin/ test/ spec/ features/ .git .github appveyor Gemfile])
    end
  end
  spec.bindir = "exe"
  spec.executables = spec.files.grep(%r{\Aexe/}) { |f| File.basename(f) }
  spec.require_paths = ["lib"]

  spec.add_dependency "jose", "~> 1.2"
  spec.add_dependency "jwt", "~> 2.9"
  spec.add_dependency "redis", "~> 5.3"
end
-----

bin/console:
#!/usr/bin/env ruby
# frozen_string_literal: true

require "bundler/setup"
require "atproto_auth"

# You can add fixtures and/or initialization code here to make experimenting
# with your gem easier. You can also use a different console, if you like.

require "irb"
IRB.start(__FILE__)
-----

bin/setup:
#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'
set -vx

bundle install

# Do any other automated setup that you need to do here
-----

bin/snapshot:
#!/usr/bin/env ruby
# frozen_string_literal: true

require "find"
require "pathname"

# SnapshotGenerator creates a comprehensive text-based representation of a project's
# structure and contents. It generates a single file that includes:
#
# 1. A tree-style visualization of the project's directory structure
# 2. The complete contents of all text-based files in the project
#
# Each file's contents are preceded by its relative path and followed by a
# separator line. Binary files and common development artifacts (like .git
# directories, temporary files, etc.) are automatically excluded.
#
# Usage:
#   generator = SnapshotGenerator.new('/path/to/project')
#   generator.generate_documentation
#
# The generated snapshot is useful for:
# - Creating complete project documentation
# - Sharing code in environments where direct file access is limited
# - Capturing project state for archival or review purposes
# - Facilitating code reviews of entire projects
#
class SnapshotGenerator
  FILE_NAME = "PROJECT_STRUCTURE.txt"

  IGNORE_PATTERNS = [
    %r{\.idea/},
    %r{\.git/},
    %r{\.github/},
    %r{\.bundle/},
    /\.DS_Store/,
    /\.gitignore/,
    /\.rspec/,
    /\.rubocop/,
    /\.byebug/,
    %r{tmp/},
    %r{log/},
    %r{coverage/},
    %r{pkg/},
    /\.gem$/,
    /\.sqlite3$/,
    /\.log$/,
    /\.lock$/,
    /#{FILE_NAME}/
  ].freeze

  TEXT_FILE_EXTENSIONS = %w[
    .rb .ru .rake .yml .yaml .json .md .txt .gemspec
    .erb .haml .slim .css .scss .js .coffee .env
    .gitignore .rspec .rubocop .travis.yml .circle
    Gemfile Rakefile README LICENSE Dockerfile
  ].freeze

  def initialize(root_path)
    @root_path = Pathname.new(root_path)
    @output_file = @root_path.join(FILE_NAME)
  end

  def generate_documentation
    File.open(@output_file, "w") do |file|
      write_directory_tree(file)
      file.puts("\n\n")
      write_file_contents(file)
    end
    puts "Documentation generated at #{@output_file}"
  end

  private

  def write_directory_tree(file)
    file.puts("Project Structure:\n")
    tree = generate_tree_structure(@root_path)
    file.puts(tree)
  end

  def generate_tree_structure(path, prefix = "")
    entries = Dir.entries(path).sort
    entries.delete(".")
    entries.delete("..")

    tree = ""
    entries.each_with_index do |entry, index|
      next if ignored_path?("#{path}/#{entry}")

      is_last = (index == entries.size - 1)
      connection = is_last ? "└── " : "├── "

      full_path = path.join(entry)
      tree += "#{prefix}#{connection}#{entry}\n"

      if File.directory?(full_path)
        new_prefix = prefix + (is_last ? "    " : "│   ")
        tree += generate_tree_structure(full_path, new_prefix)
      end
    end
    tree
  end

  def write_file_contents(file)
    Find.find(@root_path) do |path|
      next if File.directory?(path)
      next if ignored_path?(path)
      next unless text_file?(path)

      relative_path = Pathname.new(path).relative_path_from(@root_path)
      file.puts("#{relative_path}:")
      file.puts(File.read(path))
      file.puts("-----\n\n")
    end
  end

  def ignored_path?(path)
    IGNORE_PATTERNS.any? { |pattern| path.match?(pattern) }
  end

  def text_file?(path)
    TEXT_FILE_EXTENSIONS.any? { |ext| path.downcase.end_with?(ext.downcase) } ||
      text_file_content?(path)
  end

  def text_file_content?(path)
    return false unless File.file?(path)

    begin
      File.read(path, 512).encode("UTF-8", "binary", invalid: :replace, undef: :replace, replace: "")
          .match?(/\A[\r\n\t\f\x20-\x7E]*\z/)
    rescue StandardError
      false
    end
  end
end

if __FILE__ == $PROGRAM_NAME
  root_path = ARGV[0] || Dir.pwd
  SnapshotGenerator.new(root_path).generate_documentation
end
-----

examples/confidential_client/Gemfile:
# frozen_string_literal: true

source "https://rubygems.org"

gem "atproto_auth", path: "../.."
gem "dotenv"
gem "faraday"
gem "json"
gem "puma"
gem "rackup"
gem "sinatra"
gem "sinatra-contrib"
-----

examples/confidential_client/README.md:
# AT Protocol OAuth Confidential Client Example

This is an example implementation of a confidential OAuth client for the AT Protocol using the AtprotoAuth gem. It demonstrates how to implement the OAuth flow for a web application, including DPoP token binding and secure session management.

<img src="https://github.com/jhuckabee/atproto_auth/blob/main/examples/confidential_client/screenshots/screenshot-1-sign-in.png?raw=true" alt="Sign In Form Screenshot" title="Sign In Form" width="500">

<img src="https://github.com/jhuckabee/atproto_auth/blob/main/examples/confidential_client/screenshots/screenshot-2-success.png?raw=true" alt="Sign In Success Screenshot" title="Sign In Success" width="500">

## Overview

The example implements a simple web application using Sinatra that:
- Allows users to sign in with their AT Protocol handle (@handle)
- Implements the complete OAuth authorization flow
- Uses DPoP-bound tokens for API requests
- Demonstrates secure session management
- Shows how to make authenticated API calls to Bluesky

## Requirements

- Ruby 3.0+
- Bundler
- A domain name for your application that matches your client metadata
- SSL certificate for your domain (required for production)

## Setup

1. Clone the repository and navigate to the example directory:
```bash
cd examples/confidential_client
```

2. Install dependencies:
```bash
bundle install
```

3. Generate EC keys for client authentication:
```bash
bundle exec ruby scripts/generate_keys.rb > config/keys.json
```

4. Configure your client metadata:
   - Copy the example metadata file over:
     ```
     cp config/client-metadata.example.json config/client-metadata.json
     ```
   - Set the correct `client_id` URL where your metadata will be hosted
   - Configure valid `redirect_uris` for your application
   - Add your generated keys from step 3 to the `jwks` field

5. Set up environment variables:
```bash
export SESSION_SECRET=your-secure-session-secret # Required for session encryption
export PERMITTED_DOMAIN=your.domain.com # Your application's domain name 
```

## Configuration

### Host Authorization

This application requires specific domain configuration to function properly:

1. **Domain-Client Matching**: The domain where you run the application must exactly match the `client_id` domain in your client metadata. For example, if your `client_id` is `https://myapp.example.com/client-metadata.json`, the application must be accessible at `myapp.example.com`.

2. **Internet Accessibility**: The application must be accessible from the internet for AT Protocol OAuth to work. The Authorization Server needs to be able to reach your application's redirect URI during the OAuth flow.

3. **Quick Setup with Tailscale Funnel**: One easy way to expose your local development server to the internet is using Tailscale Funnel:

   1. Set up [Tailscale Funnel](https://tailscale.com/kb/1223/funnel)
   2. Ensure you have HTTPS certificates configured
   5. Start your Funnel:
      ```bash
      tailscale funnel 9292
      ```
   4. Ensure your client_id and redirect_uris match your funnel path
   5. Set the `PERMITTED_DOMAIN` environment variable to your Tailscale domain
      ```bash
      export PERMITTED_DOMAIN=machinename.xyz.ts.net
      ```
   6. Run the application (see below).

Your application will now be accessible via your Tailscale domain with HTTPS enabled.

### Session Security

The application uses encrypted sessions to store authorization data. Configure the session secret with:

```ruby
export SESSION_SECRET=your-secure-random-string
```

If not set, a random secret will be generated on startup.

## Running the Application

```bash
bundle exec rackup
```

This will start the server on `http://localhost:9292`.


## Troubleshooting

### Common Issues

1. "Invalid redirect URI":
   - Ensure your redirect URI matches exactly what's in your client metadata
   - Check that your domain matches the client_id domain

2. "Invalid client metadata":
   - Verify your client metadata is accessible at the URL specified in client_id
   - Check that your JSON is valid and contains all required fields

3. "Authorization failed":
   - Verify your JWKS configuration
   - Check that your DPoP proofs are being generated correctly
   - Ensure your client authentication is working
-----

examples/confidential_client/app.rb:
# frozen_string_literal: true

require "sinatra/base"
require "sinatra/reloader"
require "atproto_auth"
require "faraday"
require "json"
require "dotenv/load"

# Main app entry point
class ExampleApp < Sinatra::Base
  def check_stored_session(session_id)
    return false unless session_id

    settings.oauth_client.authorized?(session_id)
  rescue AtprotoAuth::SessionError
    false
  end

  configure :development do
    register Sinatra::Reloader
  end

  # Initialize the AT Protocol OAuth client
  configure do
    # Configure AtprotoAuth settings
    AtprotoAuth.configure do |config|
      config.http_client = AtprotoAuth::HttpClient.new(
        timeout: 10,
        verify_ssl: true
      )
      config.default_token_lifetime = 300
      config.dpop_nonce_lifetime = 300

      # Optionally, use Redis storage instead of in-memory
      # config.storage = AtprotoAuth::Storage::Redis.new
    end

    # Load client metadata
    metadata_path = File.join(__dir__, "config", "client-metadata.json")
    metadata = JSON.parse(File.read(metadata_path))

    # Create OAuth client
    set :oauth_client, AtprotoAuth::Client.new(
      client_id: metadata["client_id"],
      redirect_uri: metadata["redirect_uris"][0],
      metadata: metadata,
      dpop_key: metadata["jwks"]["keys"][0]
    )
  end

  set :host_authorization, {
    permitted_hosts: ["localhost", ENV.fetch("PERMITTED_DOMAIN", nil)].compact
  }

  use Rack::Session::Cookie,
      key: "atproto.session",
      expire_after: 86_400, # 1 day in seconds
      secret: ENV.fetch("SESSION_SECRET") { SecureRandom.hex(32) },
      secure: true,       # Only send over HTTPS
      httponly: true,     # Not accessible via JavaScript
      same_site: :lax     # CSRF protection

  helpers do
    def recover_session
      session_id = session[:oauth_session_id]
      return nil unless session_id

      begin
        # Check if session is still valid
        return nil unless settings.oauth_client.authorized?(session_id)

        session_id
      rescue AtprotoAuth::Client::SessionError
        # Clear invalid session
        session.delete(:oauth_session_id)
        nil
      end
    end
  end

  get "/" do
    # Check for existing session
    redirect "/authorized" if recover_session

    erb :index
  end

  get "/client-metadata.json" do
    content_type :json

    # Read metadata from config file
    metadata_path = File.join(__dir__, "config", "client-metadata.json")
    metadata = JSON.parse(File.read(metadata_path))

    # Strip private key 'd' component from each key in the JWKS
    if metadata["jwks"] && metadata["jwks"]["keys"]
      metadata["jwks"]["keys"] = metadata["jwks"]["keys"].map do |key|
        key.except("d")
      end
    end

    # Return sanitized metadata
    JSON.generate(metadata)
  end

  # Start OAuth flow
  post "/auth" do
    handle = params[:handle]

    begin
      # Start authorization flow
      auth = settings.oauth_client.authorize(
        handle: handle,
        scope: "atproto"
      )

      # Store session ID in user's browser session
      session[:oauth_session_id] = auth[:session_id]

      # Redirect to authorization URL
      redirect auth[:url]
    rescue StandardError => e
      session[:error] = "Authorization failed: #{e.message}"
      redirect "/"
    end
  end

  # OAuth callback handler
  get "/callback" do
    # Handle the callback
    result = settings.oauth_client.handle_callback(
      code: params[:code],
      state: params[:state],
      iss: params[:iss]
    )

    # Store tokens
    session[:oauth_session_id] = result[:session_id]

    redirect "/authorized"
  rescue StandardError => e
    session[:error] = "Callback failed: #{e.message}"
    redirect "/"
  end

  # Show authorized state and test API call
  get "/authorized" do
    session_id = session[:oauth_session_id]
    return redirect "/" unless check_stored_session(session_id)

    begin
      # Get current session tokens
      oauth_session = settings.oauth_client.get_tokens(session_id)

      # Check if token needs refresh
      if oauth_session[:expires_in] < 30
        # Refresh token
        oauth_session = settings.oauth_client.refresh_token(session_id)
      end

      # Make test API call to com.atproto.identity.resolveHandle
      conn = Faraday.new(url: "https://api.bsky.app") do |f|
        f.request :json
        f.response :json
      end

      # Get auth headers for request
      headers = settings.oauth_client.auth_headers(
        session_id: session_id,
        method: "GET",
        url: "https://api.bsky.app/xrpc/com.atproto.identity.resolveHandle"
      )

      # Make authenticated request
      response = conn.get("/xrpc/com.atproto.identity.resolveHandle") do |req|
        headers.each { |k, v| req.headers[k] = v }
        req.params[:handle] = "bsky.app"
      end

      @api_result = response.body
      @session = oauth_session
      erb :authorized
    rescue StandardError => e
      session[:error] = "API call failed: #{e.message}"
      redirect "/"
    end
  end

  get "/signout" do
    if session[:oauth_session_id]
      # Clean up stored session
      settings.oauth_client.remove_session(session[:oauth_session_id])
    end

    session.clear
    session[:notice] = "Successfully signed out"
    redirect "/"
  end

  # Helper method to check if user is authenticated
  def authenticated?
    return false unless session[:tokens]

    settings.oauth_client.authorized?(session[:tokens][:session_id])
  end
end
-----

examples/confidential_client/config/client-metadata.example.json:
{
  "client_id": "https://YOUR_DOMAIN_HERE/client-metadata.json",
  "client_name": "AT Protocol OAuth Ruby Example",
  "redirect_uris": ["https://YOUR_DOMAIN_HERE/callback"],
  "grant_types": ["authorization_code", "refresh_token"],
  "response_types": ["code"],
  "scope": "atproto",
  "token_endpoint_auth_method": "private_key_jwt",
  "token_endpoint_auth_signing_alg": "ES256",
  "application_type": "web",
  "dpop_bound_access_tokens": true,
  "jwks": {
    "keys": [
      {
        "use": "sig",
        "kid": "key-1",
        "x": "...",
        "crv": "P-256",
        "d": "...",
        "kty": "EC",
        "y": "..."
      }
    ]
  }
}
-----

examples/confidential_client/config/client-metadata.json:
{
  "client_id": "https://mac.tail7f768.ts.net/client-metadata.json",
  "client_name": "AT Protocol OAuth Ruby Example",
  "redirect_uris": ["https://mac.tail7f768.ts.net/callback"],
  "grant_types": ["authorization_code", "refresh_token"],
  "response_types": ["code"],
  "scope": "atproto",
  "token_endpoint_auth_method": "private_key_jwt",
  "token_endpoint_auth_signing_alg": "ES256",
  "application_type": "web",
  "dpop_bound_access_tokens": true,
  "jwks": {
    "keys": [
      {
        "use": "sig",
        "kid": "key-1",
        "x": "SzXlDk9rSyrZ3b0fVKOWFYY-AFZtld2zElycsmDZ3Xk",
        "crv": "P-256",
        "d": "OLJJKo9T9W7taz8gFd5YdsBw8cOpv3p5zPPtv2XaKcM",
        "kty": "EC",
        "y": "4hIBLl-BLD1Ypk-mvPxT2OR52ezMs4XI1MGBdhlLLm4"
      }
    ]
  }
}
-----

examples/confidential_client/config.ru:
# frozen_string_literal: true

require_relative "app"
run ExampleApp
-----

examples/confidential_client/public/client-metadata.json:
{
  "client_id": "https://mac.tail7f768.ts.net/client-metadata.json",
  "client_name": "AT Protocol OAuth Ruby Example",
  "redirect_uris": ["https://mac.tail7f768.ts.net/callback"],
  "grant_types": ["authorization_code", "refresh_token"],
  "response_types": ["code"],
  "scope": "atproto",
  "token_endpoint_auth_method": "private_key_jwt",
  "token_endpoint_auth_signing_alg": "ES256",
  "application_type": "web",
  "dpop_bound_access_tokens": true,
  "jwks": {
    "keys": [
      {
        "use": "sig",
        "kid": "key-1",
        "x": "SzXlDk9rSyrZ3b0fVKOWFYY-AFZtld2zElycsmDZ3Xk",
        "crv": "P-256",
        "kty": "EC",
        "y": "4hIBLl-BLD1Ypk-mvPxT2OR52ezMs4XI1MGBdhlLLm4"
      }
    ]
  }
}
-----

examples/confidential_client/public/styles.css:
.container {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
}

.header {
    max-width: 400px;
    margin: 0 auto;
}

.error {
    background-color: #ffebee;
    color: #c62828;
    padding: 10px;
    margin-bottom: 20px;
    border-radius: 4px;
}

.auth-form {
    max-width: 400px;
    margin: 40px auto;
}

.form-group {
    margin-bottom: 15px;
}

.form-group label {
    display: block;
    margin-bottom: 5px;
}

.form-group input {
    width: 100%;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
}

button {
    background: #2196f3;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

button:hover {
    background: #1976d2;
}

.token-info,
.api-test {
    margin-top: 20px;
    padding: 15px;
    background: #f5f5f5;
    border-radius: 4px;
}

pre {
    overflow-x: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
}

code {
    font-size: 14px;
}
-----

examples/confidential_client/scripts/generate_keys.rb:
# frozen_string_literal: true

require "jose"

# Generate a new EC key using P-256 curve
keypair = JOSE::JWK.generate_key([:ec, "P-256"])

# Get the key as a hash (need to convert from JOSE::Map)
jwk = keypair.to_map.to_h

# Pretty print the JWK to stdout
require "json"
puts JSON.pretty_generate({
                            keys: [jwk]
                          })
-----

examples/confidential_client/views/authorized.erb:
<div class="flex flex-col items-center md:flex md:flex-row md:justify-stretch md:items-center min-h-screen min-w-screen bg-white text-gray-900 dark:bg-gray-900 dark:text-gray-100">
  <div class="px-6 pt-4 md:max-w-lg md:grid md:content-center md:justify-items-end md:self-stretch md:w-1/2 md:max-w-fix md:p-4 md:text-right md:dark:border-r md:dark:border-gray-700 md:bg-gray-100 md:dark:bg-gray-800">
    <h1 class="text-xl md:text-2xl lg:text-5xl md:mt-4 mb-4 font-semibold text-brand">Successfully Authenticated!</h1>
  </div>
  <div class="w-full px-6 md:max-w-3xl md:px-12">
    <div class="space-y-8">
      <% if session[:error] %>
        <div class="mb-8 bg-red-50 border-red-700 text-red-700 p-4 rounded-md">
          <%= session[:error] %>
          <% session[:error] = nil %>
        </div>
      <% end %>

      <div class="token-info">
        <p class="mb-1 text-gray-600 dark:text-gray-400 text-sm font-medium">Token Information</p>
        <pre class="rounded-lg text-gray-700 dark:text-gray-100 bg-gray-100 dark:bg-slate-800 border border-gray-400 p-2 overflow-auto"><code><%= JSON.pretty_generate(@session) %></code></pre>
      </div>

      <div class="api-test">
        <p class="mb-1 text-gray-600 dark:text-gray-400 text-sm font-medium">Test API Call Result</p>
        <pre class="rounded-lg text-gray-700 dark:text-gray-100 bg-gray-100 dark:bg-slate-800 border border-gray-400 p-2 overflow-auto"><code><%= JSON.pretty_generate(@api_result) %></code></pre>
      </div>

      <div class="flex">
        <a href="/signout" aria-label="Signout" class="py-2 px-6 rounded-lg truncate cursor-pointer touch-manipulation tracking-wide overflow-hidden bg-blue-400 text-white">Sign out</a>
      </div>
    </div>
  </div>
</div>
-----

examples/confidential_client/views/index.erb:
<div class="flex flex-col items-center md:flex md:flex-row md:justify-stretch md:items-center min-h-screen min-w-screen bg-white text-gray-900 dark:bg-gray-900 dark:text-gray-100">
  <div class="px-6 pt-4 md:max-w-lg md:grid md:content-center md:justify-items-end md:self-stretch md:w-1/2 md:max-w-fix md:p-4 md:text-right md:dark:border-r md:dark:border-gray-700 md:bg-gray-100 md:dark:bg-gray-800">
    <h1 class="text-xl md:text-2xl lg:text-5xl md:mt-4 mb-4 font-semibold text-brand">Sign in</h1>
    <p class="hidden md:block max-w-xs text-gray-500 dark:text-gray-500">Enter your AT Protocol handle</p>
  </div>
  <div class="w-full px-6 md:max-w-3xl md:px-12">
    <form method="post" action="/auth" class="flex flex-col py-4 space-y-4">
      <div class="space-y-4">
        <% if session[:error] %>
          <div class="mb-8 bg-red-50 border-red-700 text-red-700 p-4 rounded-md">
            <%= session[:error] %>
            <% session[:error] = nil %>
          </div>
        <% end %>
        <% if session[:notice] %>
          <div class="mb-8 bg-yellow-50 border-yellow-700 text-yellow-700 p-4 rounded-md">
            <%= session[:notice] %>
            <% session[:notice] = nil %>
          </div>
        <% end %>
        <fieldset>
          <p class="mb-1 text-gray-600 dark:text-gray-400 text-sm font-medium">Handle</p>
          <div class="flex flex-col space-y-4">
            <div class="pl-1 pr-2 min-h-12 flex items-center justify-stretch rounded-lg text-gray-700 dark:text-gray-100 bg-gray-100 has-[:focus]:bg-gray-200 dark:bg-gray-800 dark:has-[:focus]:bg-gray-700 outline-none border-solid border-2 border-transparent hover:border-gray-400 has-[:focus]:border-brand hover:has-[:focus]:border-brand dark:hover:border-gray-500">
              <div class="self-start shrink-0 grow-0 w-8 h-12 flex items-center justify-center text-gray-500">
                <div>
                  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="w-5">
                    <path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M12 4a8 8 0 1 0 4.21 14.804 1 1 0 0 1 1.054 1.7A9.958 9.958 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 1.104-.27 2.31-.949 3.243-.716.984-1.849 1.6-3.331 1.465a4.207 4.207 0 0 1-2.93-1.585c-.94 1.21-2.388 1.94-3.985 1.715-2.53-.356-4.04-2.91-3.682-5.458.358-2.547 2.514-4.586 5.044-4.23.905.127 1.68.536 2.286 1.126a1 1 0 0 1 1.964.368l-.515 3.545v.002a2.222 2.222 0 0 0 1.999 2.526c.75.068 1.212-.21 1.533-.65.358-.493.566-1.245.566-2.067a8 8 0 0 0-8-8Zm-.112 5.13c-1.195-.168-2.544.819-2.784 2.529-.24 1.71.784 3.03 1.98 3.198 1.195.168 2.543-.819 2.784-2.529.24-1.71-.784-3.03-1.98-3.198Z"></path>
                  </svg>
                </div>
              </div>
              <div class="relative">
                <input class="w-full bg-transparent bg-clip-padding text-base text-inherit outline-none dark:placeholder-gray-500" name="handle" type="text" placeholder="handle.bsky.social" aria-label="Handle" autocapitalize="none" autocorrect="off" autocomplete="username" spellcheck="false" dir="auto" enterkeyhint="next" required title="valid handle">
              </div>
            </div>
          </div>
        </fieldset>
      </div>
      <div class="pt-4">
        <button role="Button" type="submit" aria-label="Next" class="py-2 px-6 rounded-lg truncate cursor-pointer touch-manipulation tracking-wide overflow-hidden bg-blue-400 text-white">Next</button>
      </div>
    </form>
  </div>
</div>
-----

examples/confidential_client/views/layout.erb:
<!DOCTYPE html>
<html>
<head>
  <title>AT Protocol OAuth Example</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
<%= yield %>
</body>
</html>
-----

lib/atproto_auth/client.rb:
# frozen_string_literal: true

module AtprotoAuth
  # Main client class for AT Protocol OAuth implementation. Handles the complete
  # OAuth flow including authorization, token management, and identity verification.
  class Client
    # Error raised when authorization callback fails
    class CallbackError < Error; end

    # Error raised when token operations fail
    class TokenError < Error; end

    # Error raised when session operations fail
    class SessionError < Error
      attr_reader :session_id

      def initialize(message, session_id: nil)
        @session_id = session_id
        super(message)
      end
    end

    # @return [String] OAuth client ID
    attr_reader :client_id
    # @return [String] OAuth redirect URI
    attr_reader :redirect_uri
    # @return [ClientMetadata] Validated client metadata
    attr_reader :client_metadata
    # @return [SessionManager] Session state manager
    attr_reader :session_manager
    # @return [Identity::Resolver] Identity resolver
    attr_reader :identity_resolver
    # @return [DPoP::Client] DPoP client
    attr_reader :dpop_client

    # Creates a new AT Protocol OAuth client
    # @param client_id [String] OAuth client ID URL
    # @param redirect_uri [String] OAuth redirect URI
    # @param metadata [Hash, nil] Optional pre-loaded client metadata
    # @param dpop_key [Hash, nil] Optional existing DPoP key in JWK format
    # @raise [Error] if configuration is invalid
    def initialize(client_id:, redirect_uri:, metadata: nil, dpop_key: nil)
      @client_id = client_id
      @redirect_uri = redirect_uri

      # Initialize core dependencies
      @client_metadata = load_client_metadata(metadata)
      validate_redirect_uri!

      @session_manager = State::SessionManager.new
      @identity_resolver = Identity::Resolver.new
      @dpop_client = initialize_dpop(dpop_key)
    end

    # Begins an authorization flow and generates authorization URL
    # @param handle [String, nil] Optional user handle
    # @param pds_url [String, nil] Optional PDS URL
    # @param scope [String] OAuth scope (must include "atproto")
    # @return [Hash] Authorization details including :url and :session_id
    # @raise [Error] if parameters are invalid or resolution fails
    def authorize(handle: nil, pds_url: nil, scope: "atproto")
      validate_auth_params!(handle, pds_url, scope)

      # Create new session
      session = session_manager.create_session(
        client_id: client_id,
        scope: scope
      )

      # Store session with storage backend
      session_manager.update_session(session)

      # Resolve identity and authorization server if handle provided
      if handle
        auth_info = resolve_from_handle(handle, session)
      elsif pds_url
        auth_info = resolve_from_pds(pds_url, session)
      else
        raise Error, "Either handle or pds_url must be provided"
      end

      # Generate authorization URL
      auth_url = generate_authorization_url(
        auth_info[:server],
        session,
        login_hint: handle
      )

      {
        url: auth_url,
        session_id: session.session_id
      }
    end

    # Handles the authorization callback and completes token exchange
    # @param code [String] Authorization code from callback
    # @param state [String] State parameter from callback
    # @param iss [String] Issuer from callback (required by AT Protocol OAuth)
    # @return [Hash] Token response including :access_token and :session_id
    # @raise [CallbackError] if callback validation fails
    # @raise [TokenError] if token exchange fails
    def handle_callback(code:, state:, iss:)
      # Find and validate session
      session = session_manager.get_session_by_state(state)
      raise CallbackError, "Invalid state parameter" unless session

      # Verify issuer matches session
      raise CallbackError, "Issuer mismatch" unless session.auth_server && session.auth_server.issuer == iss

      AtprotoAuth.storage.with_lock(Storage::KeyBuilder.lock_key("session", session.session_id), ttl: 30) do
        # Exchange code for tokens
        token_response = exchange_code(
          code: code,
          session: session
        )

        # Validate token response
        validate_token_response!(token_response, session)

        # Create token set and store in session
        token_set = State::TokenSet.new(
          access_token: token_response["access_token"],
          token_type: token_response["token_type"],
          expires_in: token_response["expires_in"],
          refresh_token: token_response["refresh_token"],
          scope: token_response["scope"],
          sub: token_response["sub"]
        )
        session.tokens = token_set

        # Update stored session
        session_manager.update_session(session)

        {
          access_token: token_set.access_token,
          token_type: token_set.token_type,
          expires_in: (token_set.expires_at - Time.now).to_i,
          refresh_token: token_set.refresh_token,
          scope: token_set.scope,
          session_id: session.session_id
        }
      end
    end

    # Gets active tokens for a session
    # @param session_id [String] ID of session to get tokens for
    # @return [Hash, nil] Current token information if session exists and is authorized
    def get_tokens(session_id)
      session = session_manager.get_session(session_id)
      return nil unless session&.authorized?

      {
        access_token: session.tokens.access_token,
        token_type: session.tokens.token_type,
        expires_in: (session.tokens.expires_at - Time.now).to_i,
        refresh_token: session.tokens.refresh_token,
        scope: session.tokens.scope
      }
    end

    # Refreshes tokens for a session
    # @param session_id [String] ID of session to refresh
    def refresh_token(session_id)
      session = session_manager.get_session(session_id)
      raise TokenError, "Invalid session" unless session
      raise TokenError, "Session not authorized" unless session.renewable?

      AtprotoAuth.storage.with_lock(Storage::KeyBuilder.lock_key("session", session.session_id), ttl: 30) do
        refresher = Token::Refresh.new(
          session: session,
          dpop_client: @dpop_client,
          auth_server: session.auth_server,
          client_metadata: client_metadata
        )

        new_tokens = refresher.perform!
        session.tokens = new_tokens

        # Update stored session
        session_manager.update_session(session)

        {
          access_token: new_tokens.access_token,
          token_type: new_tokens.token_type,
          expires_in: (new_tokens.expires_at - Time.now).to_i,
          refresh_token: new_tokens.refresh_token,
          scope: new_tokens.scope,
          session_id: session.session_id
        }
      end
    end

    # Checks if a session has valid tokens
    # @param session_id [String] ID of session to check
    # @return [Boolean] true if session exists and has valid tokens
    def authorized?(session_id)
      session = session_manager.get_session(session_id)
      session&.authorized? || false
    end

    # Generates headers for an authenticated request
    # @param session_id [String] ID of session to use
    # @param method [String] HTTP method for the request
    # @param url [String] Full URL for the request
    # @return [Hash] Headers to add to request
    # @raise [TokenError] if session is invalid or unauthorized
    def auth_headers(session_id:, method:, url:)
      session = session_manager.get_session(session_id)
      raise TokenError, "Invalid session" unless session
      raise TokenError, "Session not authorized" unless session.authorized?

      # Generate DPoP proof
      proof = dpop_client.generate_proof(
        http_method: method,
        http_uri: url,
        access_token: session.tokens.access_token
      )

      {
        "Authorization" => "DPoP #{session.tokens.access_token}",
        "DPoP" => proof
      }
    end

    # Removes a session and its stored data
    # @param session_id [String] ID of session to remove
    # @return [void]
    def remove_session(session_id)
      key = Storage::KeyBuilder.session_key(session_id)
      AtprotoAuth.storage.delete(key)
      session_manager.remove_session(session_id)
    end

    # Cleans up expired sessions from storage
    # @return [void]
    def cleanup_expired_sessions
      session_manager.cleanup_expired
    end

    private

    def load_client_metadata(metadata)
      if metadata
        ClientMetadata.new(metadata)
      else
        ClientMetadata.from_url(@client_id)
      end
    end

    def validate_redirect_uri!
      valid = @client_metadata.redirect_uris.include?(@redirect_uri)
      raise Error, "redirect_uri not found in client metadata" unless valid
    end

    def initialize_dpop(key)
      key_manager = if key
                      DPoP::KeyManager.from_jwk(key)
                    else
                      DPoP::KeyManager.new
                    end

      DPoP::Client.new(key_manager: key_manager)
    end

    def validate_auth_params!(handle, pds_url, scope)
      raise Error, "scope must include 'atproto'" unless scope.split.include?("atproto")
      raise Error, "handle or pds_url must be provided" if handle.nil? && pds_url.nil?
      raise Error, "cannot provide both handle and pds_url" if handle && pds_url
    end

    def resolve_from_handle(handle, session)
      # Resolve handle to DID document
      resolution = @identity_resolver.resolve_handle(handle)
      session.did = resolution[:did]

      # Get authorization server from PDS
      server = resolve_auth_server(resolution[:pds])
      session.authorization_server = server

      # Update stored session
      session_manager.update_session(session)

      { server: server, pds: resolution[:pds] }
    end

    def resolve_from_pds(pds_url, session)
      # Get authorization server from PDS
      server = resolve_auth_server(pds_url)
      session.authorization_server = server

      # Update stored session
      session_manager.update_session(session)

      { server: server, pds: pds_url }
    end

    def resolve_auth_server(pds_url)
      # Get resource server metadata
      resource_server = ServerMetadata::ResourceServer.from_url(pds_url)
      auth_server_url = resource_server.authorization_servers.first

      # Get and validate authorization server metadata
      ServerMetadata::AuthorizationServer.from_issuer(auth_server_url)
    end

    def generate_authorization_url(auth_server, session, login_hint: nil)
      # Create PAR client
      par_client = PAR::Client.new(
        endpoint: auth_server.pushed_authorization_request_endpoint,
        dpop_client: @dpop_client
      )

      signing_key = if client_metadata.jwks && !client_metadata.jwks["keys"].empty?
                      key_data = client_metadata.jwks["keys"].first
                      JOSE::JWK.from_map(key_data)
                    else
                      JOSE::JWK.generate_key([:ec, "P-256"])
                    end

      client_assertion = PAR::ClientAssertion.new(
        client_id: client_id,
        signing_key: signing_key
      )

      # Build PAR request
      par_request = PAR::Request.build do |config|
        config.client_id = client_id
        config.redirect_uri = redirect_uri
        config.state = session.state_token
        config.scope = session.scope
        config.login_hint = login_hint if login_hint

        # Add PKCE parameters
        config.code_challenge = session.pkce_challenge
        config.code_challenge_method = "S256"

        # Add client assertion
        config.client_assertion = client_assertion.generate_jwt(
          audience: auth_server.issuer
        )
        config.client_assertion_type = PAR::CLIENT_ASSERTION_TYPE

        # Add DPoP proof
        proof = @dpop_client.generate_proof(
          http_method: "POST",
          http_uri: auth_server.pushed_authorization_request_endpoint
        )
        config.dpop_proof = proof
      end

      # Submit PAR request
      response = par_client.submit(par_request)

      # Build final authorization URL
      par_client.authorization_url(
        authorize_endpoint: auth_server.authorization_endpoint,
        request_uri: response.request_uri,
        client_id: client_id
      )
    end

    def exchange_code(code:, session:)
      # Initial token request without nonce
      response = make_token_request(code, session)

      # Handle DPoP nonce requirement
      if requires_dpop_nonce?(response)
        # Extract and store nonce from error response
        extract_dpop_nonce(response)
        dpop_client.process_response(response[:headers], session.auth_server.issuer)

        # Retry request with nonce
        response = make_token_request(code, session)
      end

      raise TokenError, "Token request failed: #{response[:status]}" unless response[:status] == 200

      begin
        JSON.parse(response[:body])
      rescue JSON::ParserError => e
        raise TokenError, "Invalid token response: #{e.message}"
      end
    end

    def make_token_request(code, session)
      # Generate proof
      proof = dpop_client.generate_proof(
        http_method: "POST",
        http_uri: session.auth_server.token_endpoint
      )

      body = {
        grant_type: "authorization_code",
        code: code,
        redirect_uri: redirect_uri,
        client_id: client_id,
        code_verifier: session.pkce_verifier
      }

      # Add client authentication
      if client_metadata.confidential?
        signing_key = JOSE::JWK.from_map(client_metadata.jwks["keys"].first)
        client_assertion = PAR::ClientAssertion.new(
          client_id: client_id,
          signing_key: signing_key
        )

        body.merge!(
          client_assertion_type: PAR::CLIENT_ASSERTION_TYPE,
          client_assertion: client_assertion.generate_jwt(
            audience: session.auth_server.issuer
          )
        )
      end

      AtprotoAuth.configuration.http_client.post(
        session.auth_server.token_endpoint,
        body: body,
        headers: {
          "Content-Type" => "application/x-www-form-urlencoded",
          "DPoP" => proof
        }
      )
    end

    def requires_dpop_nonce?(response)
      return false unless response[:status] == 400

      error_data = JSON.parse(response[:body])
      error_data["error"] == "use_dpop_nonce"
    rescue JSON::ParserError
      false
    end

    def extract_dpop_nonce(response)
      headers = response[:headers]
      nonce = headers["DPoP-Nonce"] ||
              headers["dpop-nonce"] ||
              headers["Dpop-Nonce"]

      raise TokenError, "No DPoP nonce provided in error response" unless nonce

      nonce
    end

    def validate_token_response!(response, session)
      # Required fields
      %w[access_token token_type expires_in scope sub].each do |field|
        raise TokenError, "Missing #{field} in token response" unless response[field]
      end

      # Token type must be DPoP
      raise TokenError, "Invalid token_type: #{response["token_type"]}" unless response["token_type"] == "DPoP"

      # Scope must include atproto
      raise TokenError, "Missing atproto scope in token response" unless response["scope"].split.include?("atproto")

      # If we have a pre-resolved DID, verify it matches
      raise TokenError, "Subject mismatch in token response" if session.did && session.did != response["sub"]

      # Process DPoP-Nonce from response headers if present
      return unless response[:headers] && response[:headers]["DPoP-Nonce"]

      dpop_client.process_response(
        response[:headers],
        session.auth_server.issuer
      )
    end
  end
end
-----

lib/atproto_auth/client_metadata.rb:
# frozen_string_literal: true

require "uri"
require "json"

module AtprotoAuth
  module ApplicationType
    ALL = [
      WEB = "web",
      NATIVE = "native"
    ].freeze
  end

  # Handles validation and management of AT Protocol OAuth client metadata according to
  # the specification. This includes required fields like client_id and redirect URIs,
  # optional metadata like client name and logo, and authentication configuration for
  # confidential clients. Validates that all fields conform to the protocol's requirements,
  # including:
  # - Application type (web/native) validation and redirect URI rules
  # - Required scopes and grant types
  # - JWKS configuration for confidential clients
  # - DPoP binding requirements
  # - URI scheme and format validation
  class ClientMetadata
    # Required fields
    attr_reader :application_type, :client_id, :grant_types, :response_types, :redirect_uris, :scope
    # Optional fields
    attr_reader :client_name, :client_uri, :logo_uri, :tos_uri, :policy_uri
    # Authentication and key-related fields
    attr_reader :token_endpoint_auth_method, :jwks, :jwks_uri

    # Initializes a new ClientMetadata instance from metadata hash.
    # @param metadata [Hash] Client metadata.
    # @raise [InvalidClientMetadata] if metadata is invalid.
    def initialize(metadata)
      validate_and_set_metadata!(metadata)
    end

    # Fetches client metadata from a URL and creates a new instance.
    # @param url [String] URL to fetch metadata from.
    # @return [ClientMetadata] new instance with fetched metadata.
    # @raise [InvalidClientMetadata] if metadata is invalid or cannot be fetched.
    def self.from_url(url)
      validate_url!(url)
      response = fetch_metadata(url)
      metadata = parse_metadata(response[:body])
      validate_client_id!(metadata["client_id"], url)
      new(metadata)
    end

    # Determines if the client is confidential (has authentication keys).
    # @return [Boolean] true if client is confidential.
    def confidential?
      token_endpoint_auth_method == "private_key_jwt"
    end

    private

    def validate_and_set_metadata!(metadata)
      # Required fields
      @application_type = validate_application_type(metadata["application_type"])
      @client_id = validate_client_id!(metadata["client_id"])
      @grant_types = validate_grant_types!(metadata["grant_types"])
      @response_types = validate_response_types!(metadata["response_types"])
      @redirect_uris = validate_redirect_uris!(metadata["redirect_uris"])
      @scope = validate_scope!(metadata["scope"])

      validate_dpop!(metadata)

      # Optional fields
      @client_name = metadata["client_name"]
      @client_uri = validate_client_uri(metadata["client_uri"])
      @logo_uri = validate_https_uri(metadata["logo_uri"])
      @tos_uri = validate_https_uri(metadata["tos_uri"])
      @policy_uri = validate_https_uri(metadata["policy_uri"])

      # Authentication methods
      validate_auth_methods!(metadata)
    end

    def validate_client_id!(client_id)
      raise InvalidClientMetadata, "client_id is required" unless client_id

      uri = URI(client_id)
      unless uri.scheme == "https" || (uri.scheme == "http" && uri.host == "localhost")
        raise InvalidClientMetadata, "client_id must be HTTPS or localhost HTTP URL"
      end

      client_id
    end

    def validate_grant_types!(grant_types)
      raise InvalidClientMetadata, "grant_types is required" unless grant_types

      valid_types = %w[authorization_code refresh_token]
      unless grant_types.include?("authorization_code") && (grant_types - valid_types).empty?
        raise InvalidClientMetadata, "grant_types must include authorization_code and optionally refresh_token"
      end

      grant_types
    end

    def validate_response_types!(response_types)
      raise InvalidClientMetadata, "response_types is required" unless response_types
      raise InvalidClientMetadata, "response_types must include 'code'" unless response_types.include?("code")

      response_types
    end

    def validate_redirect_uris!(uris)
      raise InvalidClientMetadata, "redirect_uris is required" if uris.nil? || uris.none?

      uris.each { |uri| validate_redirect_uri!(URI(uri)) }
      uris
    end

    def validate_redirect_uri!(uri)
      case application_type
      when ApplicationType::WEB
        if uri.host != "127.0.0.1" && uri.scheme != "https"
          raise InvalidClientMetadata, "web clients must use HTTPS redirect URIs #{uri}"
        end

        validate_redirect_uri_origin!(uri)
      when ApplicationType::NATIVE
        validate_native_redirect_uri!(uri)
      end
    end

    def validate_redirect_uri_origin!(uri)
      client_origin = URI(@client_id).host
      valid = client_origin == "localhost" ? true : uri.host == client_origin
      raise InvalidClientMetadata, "redirect URI must match client_id origin" unless valid
    end

    def validate_native_redirect_uri!(uri)
      if uri.scheme == "http"
        unless ["127.0.0.1", "[::1]"].include?(uri.host)
          raise InvalidClientMetadata, "HTTP redirect URIs for native clients must use loopback IP"
        end
      else
        validate_custom_scheme!(uri)
      end
    end

    def validate_custom_scheme!(uri)
      reversed_host = URI(@client_id).host.split(".").reverse
      scheme_parts = uri.scheme.split(".")
      unless scheme_parts == reversed_host
        raise InvalidClientMetadata, "custom scheme must match reversed client_id domain"
      end
      raise InvalidClientMetadata, "custom scheme URI must have single path component" unless uri.path == "/"
    end

    def validate_scope!(scope)
      raise InvalidClientMetadata, "scope is required" unless scope

      scope_values = scope.split
      raise InvalidClientMetadata, "atproto scope is required" unless scope_values.include?("atproto")

      # validate_offline_access_scope!(scope_values)
      scope
    end

    def validate_offline_access_scope!(scope_values)
      has_refresh = @grant_types&.include?("refresh_token")
      has_offline = scope_values.include?("offline_access")
      return unless has_refresh != has_offline

      raise InvalidClientMetadata, "offline_access scope must match refresh_token grant type"
    end

    def validate_application_type(type)
      type ||= ApplicationType::WEB # Default to web
      unless ApplicationType::ALL.include?(type)
        raise InvalidClientMetadata,
              "application_type must be 'web' or 'native'"
      end

      type
    end

    def validate_client_uri(uri)
      return unless uri
      raise InvalidClientMetadata, "client_uri must match client_id origin" unless URI(uri).host == URI(@client_id).host

      uri
    end

    def validate_https_uri(uri)
      return unless uri
      raise InvalidClientMetadata, "URI must use HTTPS" unless URI(uri).scheme == "https"

      uri
    end

    def validate_jwks!(jwks)
      raise InvalidClientMetadata, "jwks must have keys array" unless jwks["keys"].is_a?(Array)

      jwks["keys"].each_with_index do |key, index|
        has_key_use_sig = key["use"] == "sig"
        has_key_ops_sign = key["key_ops"]&.include?("sign")
        if !has_key_use_sig && !has_key_ops_sign
          raise InvalidClientMetadata, "jwks.keys.#{index} must have use='sig' or key_ops including 'sign'"
        end

        raise InvalidClientMetadata, "jwks.keys.#{index} must have kid" unless key["kid"]
      end
    end

    def validate_auth_methods!(metadata)
      @token_endpoint_auth_method = metadata["token_endpoint_auth_method"]
      return unless @token_endpoint_auth_method == "private_key_jwt"

      # Validate auth signing algorithm
      @token_endpoint_auth_signing_alg = metadata["token_endpoint_auth_signing_alg"]
      unless @token_endpoint_auth_signing_alg == "ES256"
        raise InvalidClientMetadata, "token_endpoint_auth_signing_alg must be ES256"
      end

      @jwks = metadata["jwks"]
      @jwks_uri = metadata["jwks_uri"]
      raise InvalidClientMetadata, "cannot use both jwks and jwks_uri" if @jwks && @jwks_uri
      raise InvalidClientMetadata, "confidential clients must provide jwks or jwks_uri" unless @jwks || @jwks_uri

      validate_jwks!(@jwks) if @jwks
      validate_https_uri(@jwks_uri) if @jwks_uri
    end

    def validate_dpop!(metadata)
      return if metadata["dpop_bound_access_tokens"] == true

      raise InvalidClientMetadata, "dpop_bound_access_tokens must be true"
    end

    class << self
      private

      def validate_url!(url)
        uri = URI(url)
        return if uri.scheme == "https" || uri.host == "localhost"

        raise InvalidClientMetadata, "client_id must use HTTPS except for localhost"
      end

      def fetch_metadata(url)
        AtprotoAuth.configuration.http_client&.get(url) ||
          raise(InvalidClientMetadata, "HTTP client not configured")
      end

      def parse_metadata(body)
        JSON.parse(body)
      rescue JSON::ParserError => e
        raise InvalidClientMetadata, "Invalid JSON in client metadata: #{e.message}"
      end

      def validate_client_id!(metadata_client_id, url)
        return if metadata_client_id == url

        raise InvalidClientMetadata, "client_id mismatch: #{metadata_client_id} != #{url}"
      end
    end
  end
end
-----

lib/atproto_auth/configuration.rb:
# frozen_string_literal: true

require "logger"

module AtprotoAuth
  class ConfigurationError < Error; end

  # Configuration class for global AtprotoAuth settings
  class Configuration
    attr_accessor :default_token_lifetime,
                  :dpop_nonce_lifetime,
                  :encryption,
                  :http_client,
                  :logger,
                  :storage

    def initialize
      @default_token_lifetime = 300 # 5 minutes in seconds
      @dpop_nonce_lifetime = 300 # 5 minutes in seconds
      @encryption = nil
      @http_client = nil
      @logger = Logger.new($stdout)
      @storage = AtprotoAuth::Storage::Memory.new
    end

    # Validates the current configuration
    # @raise [ConfigurationError] if configuration is invalid
    def validate!
      validate_storage!
      validate_http_client!
      true
    end

    private

    def validate_storage!
      raise ConfigurationError, "Storage must be configured" if @storage.nil?
      return if @storage.is_a?(AtprotoAuth::Storage::Interface)

      raise ConfigurationError, "Storage must implement Storage::Interface"
    end

    def validate_http_client!
      return if @http_client.nil? # Allow nil for testing

      return if @http_client.respond_to?(:get) && @http_client.respond_to?(:post)

      raise ConfigurationError, "HTTP client must implement get and post methods"
    end
  end
end
-----

lib/atproto_auth/dpop/client.rb:
# frozen_string_literal: true

module AtprotoAuth
  module DPoP
    # High-level client for managing DPoP operations. Integrates key management,
    # proof generation, and nonce tracking to provide a complete DPoP client
    # implementation according to RFC 9449.
    #
    # This client handles:
    # - Key management for signing proofs
    # - Proof generation for HTTP requests
    # - Nonce tracking across servers
    # - Header construction for requests
    # - Response processing for nonce updates
    class Client
      # Error raised for DPoP client operations
      class Error < AtprotoAuth::Error; end

      # @return [KeyManager] DPoP key manager instance
      attr_reader :key_manager
      # @return [ProofGenerator] DPoP proof generator instance
      attr_reader :proof_generator
      # @return [NonceManager] DPoP nonce manager instance
      attr_reader :nonce_manager

      # Creates a new DPoP client
      # @param key_manager [KeyManager, nil] Optional existing key manager
      # @param nonce_ttl [Integer, nil] Optional TTL for nonces in seconds
      def initialize(key_manager: nil, nonce_ttl: nil)
        @key_manager = key_manager || KeyManager.new
        @nonce_manager = NonceManager.new(ttl: nonce_ttl)
        @proof_generator = ProofGenerator.new(@key_manager)
      end

      # Generates a DPoP proof for an HTTP request
      # @param http_method [String] HTTP method (e.g., "POST")
      # @param http_uri [String] Full request URI
      # @param access_token [String, nil] Optional access token to bind to proof
      # @return [String] The DPoP proof JWT
      # @raise [Error] if proof generation fails
      def generate_proof(http_method:, http_uri:, access_token: nil, nonce: nil)
        uri = URI(http_uri)
        server_url = "#{uri.scheme}://#{uri.host}#{":#{uri.port}" if uri.port != uri.default_port}"

        # Use provided nonce or get one from the manager
        nonce ||= @nonce_manager.get(server_url)

        @proof_generator.generate(
          http_method: http_method,
          http_uri: http_uri,
          nonce: nonce,
          access_token: access_token
        )
      rescue StandardError => e
        raise Error, "Failed to generate proof: #{e.message}"
      end

      # Updates stored nonce from server response
      # @param response_headers [Hash] Response headers
      # @param server_url [String] Server's base URL
      # @return [void]
      # @raise [Error] if nonce update fails
      def process_response(response_headers, server_url)
        return unless response_headers

        # Look for DPoP-Nonce header (case insensitive)
        nonce = response_headers.find { |k, _| k.downcase == "dpop-nonce" }&.last
        return unless nonce

        # Store new nonce for future requests
        @nonce_manager.update(nonce: nonce, server_url: server_url)
      rescue StandardError => e
        raise Error, "Failed to process response: #{e.message}"
      end

      # Constructs DPoP header value for a request
      # @param proof [String] The DPoP proof JWT
      # @return [Hash] Headers to add to request
      def request_headers(proof)
        {
          "DPoP" => proof
        }
      end

      # Gets the current public key in JWK format
      # @return [Hash] JWK representation of public key
      def public_key
        @key_manager.public_jwk
      end

      # Exports the current keypair as JWK
      # @param include_private [Boolean] Whether to include private key
      # @return [Hash] JWK representation of keypair
      def export_key(include_private: false)
        @key_manager.to_jwk(include_private: include_private)
      end

      private

      def extract_nonce(headers)
        # Headers can be hash with string or symbol keys, or http headers object
        headers = headers.to_h if headers.respond_to?(:to_h)

        # Try different common header key formats
        nonce = headers["DPoP-Nonce"] ||
                headers["dpop-nonce"] ||
                headers[:dpop_nonce]

        nonce&.strip
      end

      def origin_for_uri(uri)
        port = uri.port
        port = nil if (uri.scheme == "https" && port == 443) || (uri.scheme == "http" && port == 80)

        origin = "#{uri.scheme}://#{uri.host}"
        origin = "#{origin}:#{port}" if port
        origin
      end
    end
  end
end
-----

lib/atproto_auth/dpop/key_manager.rb:
# frozen_string_literal: true

module AtprotoAuth
  module DPoP
    # Manages ES256 keypair generation and storage for DPoP proofs.
    # Provides functionality to generate new keys and store them securely.
    # Uses JOSE for cryptographic operations and key format handling.
    class KeyManager
      # Error raised when key operations fail
      class KeyError < AtprotoAuth::Error; end

      # Default curve for ES256 key generation
      CURVE = "P-256"
      # Default algorithm for key usage
      ALGORITHM = "ES256"

      # @return [JOSE::JWK] The current DPoP keypair
      attr_reader :keypair

      # Creates a new KeyManager instance with an optional existing keypair
      # @param keypair [JOSE::JWK, nil] Optional existing keypair to use
      # @raise [KeyError] if the provided keypair is invalid
      def initialize(keypair = nil)
        @keypair = keypair || generate_keypair
        validate_keypair!
      end

      # Generates a new ES256 keypair for DPoP usage
      # @return [JOSE::JWK] The newly generated keypair
      # @raise [KeyError] if key generation fails
      def generate_keypair
        # Generate base keypair
        base_key = JOSE::JWK.generate_key([:ec, CURVE])
        base_map = base_key.to_map

        # Create new map with all required properties
        key_map = {
          "kty" => base_map["kty"],
          "crv" => base_map["crv"],
          "x" => base_map["x"],
          "y" => base_map["y"],
          "d" => base_map["d"],
          "use" => "sig",
          "kid" => generate_kid(base_map)
        }

        # Create new JWK with all properties
        JOSE::JWK.from_map(key_map)
      rescue StandardError => e
        raise KeyError, "Failed to generate keypair: #{e.message}"
      end

      # Returns the public key in JWK format
      # @return [Hash] JWK representation of the public key
      def public_jwk
        jwk = @keypair.to_public.to_map.to_h
        # If somehow the properties aren't set, add them
        jwk["use"] ||= "sig"
        jwk["kid"] ||= generate_kid(jwk)
        jwk
      rescue StandardError => e
        raise KeyError, "Failed to export public key: #{e.message}"
      end

      # Signs data using the private key
      # @param data [String] Data to sign
      # @return [String] The signature
      # @raise [KeyError] if signing fails
      def sign(data)
        @keypair.sign(data).compact
      rescue StandardError => e
        raise KeyError, "Failed to sign data: #{e.message}"
      end

      def sign_segments(header, payload)
        # Deep transform all keys to strings to avoid symbol comparison issues
        header = deep_stringify_keys(header)
        payload = deep_stringify_keys(payload)

        # Configure JOSE to use ES256 for signing
        signing_config = { "alg" => "ES256" }

        # Merge our header with JOSE's required fields
        full_header = header.merge(signing_config)

        # Convert payload to JSON string before signing
        payload_json = JSON.generate(payload)

        # Create the JWS with our header and payload
        jws = @keypair.sign(payload_json, full_header)

        # Get the compact serialization
        jws.compact
      rescue StandardError => e
        raise KeyError, "Failed to sign segments: #{e.message}"
      end

      def deep_stringify_keys(obj)
        case obj
        when Hash
          obj.each_with_object({}) do |(k, v), hash|
            hash[k.to_s] = deep_stringify_keys(v)
          end
        when Array
          obj.map { |v| deep_stringify_keys(v) }
        else
          obj
        end
      end

      # Verifies a signed JWS
      # @param signed_jws [String] The complete signed JWS to verify
      # @return [Boolean] True if signature is valid
      # @raise [KeyError] if verification fails
      def verify(signed_jws)
        verified, _payload, = @keypair.verify(signed_jws)
        verified
      rescue StandardError => e
        raise KeyError, "Failed to verify signature: #{e.message}"
      end

      # Exports the keypair in JWK format
      # @param include_private [Boolean] Whether to include private key
      # @return [Hash] JWK representation of the keypair
      # @raise [KeyError] if export fails
      def to_jwk(include_private: false)
        key = include_private ? @keypair : @keypair.to_public
        key.to_map
      rescue StandardError => e
        raise KeyError, "Failed to export key: #{e.message}"
      end

      # Creates a KeyManager instance from a JWK
      # @param jwk [Hash] JWK representation of a keypair
      # @return [KeyManager] New KeyManager instance
      # @raise [KeyError] if import fails
      def self.from_jwk(jwk)
        keypair = JOSE::JWK.from_map(jwk)
        new(keypair)
      rescue StandardError => e
        raise KeyError, "Failed to import key: #{e.message}"
      end

      private

      def generate_kid(jwk)
        # Generate a key ID based on the key's components
        components = [
          jwk["kty"],
          jwk["crv"],
          jwk["x"],
          jwk["y"]
        ].join(":")

        # Create a SHA-256 hash and take first 8 bytes
        digest = OpenSSL::Digest::SHA256.digest(components)
        Base64.urlsafe_encode64(digest[0..7], padding: false)
      end

      # Validates that the keypair meets DPoP requirements
      # @raise [KeyError] if validation fails
      def validate_keypair!
        # Check that we have a valid EC key
        raise KeyError, "Invalid key type: #{@keypair.kty}, must be :ec" unless @keypair.kty.is_a?(JOSE::JWK::KTY_EC)

        # Verify the curve
        curve = @keypair.to_map["crv"]
        raise KeyError, "Invalid curve: #{curve}, must be #{CURVE}" unless curve == CURVE

        # Verify we can perform basic operations
        test_data = "test"
        signed = sign(test_data)
        raise KeyError, "Key validation failed: signature verification error" unless verify(signed)
      rescue StandardError => e
        raise KeyError, "Key validation failed: #{e.message}"
      end

      def sign_message(message)
        # Create SHA-256 digest of message
        digest = OpenSSL::Digest::SHA256.digest(message)

        # Get EC key from JOSE JWK
        ec_key = extract_ec_key

        # Sign using ECDSA
        signature = ec_key.sign(OpenSSL::Digest.new("SHA256"), digest)

        # Convert to raw r|s format required for JWTs
        asn1_to_raw(signature)
      end

      def extract_ec_key
        # Extract the raw EC key from JOSE JWK
        key_data = @keypair.to_map
        raise KeyError, "Private key required for signing" unless key_data["d"] # Private key component

        group = OpenSSL::PKey::EC::Group.new("prime256v1")
        key = OpenSSL::PKey::EC.new(group)

        # Convert base64url to hex string for BN
        d = bin_to_hex(Base64.urlsafe_decode64(key_data["d"]))
        x = bin_to_hex(Base64.urlsafe_decode64(key_data["x"]))
        y = bin_to_hex(Base64.urlsafe_decode64(key_data["y"]))

        # Create BNs from hex strings
        key.private_key = OpenSSL::BN.new(d, 16)

        # Set public key point
        point = OpenSSL::PKey::EC::Point.new(group)
        point.set_to_keypair(x, y)
        key.public_key = point

        key
      end

      def bin_to_hex(binary)
        binary.unpack1("H*")
      end

      def asn1_to_raw(signature)
        # Parse ASN.1 signature
        asn1 = OpenSSL::ASN1.decode(signature)
        r = asn1.value[0].value.to_s(2)
        s = asn1.value[1].value.to_s(2)

        # Pad r and s to 32 bytes each
        r = r.rjust(32, "\x00")
        s = s.rjust(32, "\x00")

        # Concatenate r|s
        r + s
      end
    end
  end
end
-----

lib/atproto_auth/dpop/nonce_manager.rb:
# frozen_string_literal: true

module AtprotoAuth
  module DPoP
    # Manages DPoP nonces provided by servers during the OAuth flow.
    # Tracks separate nonces for each server using persistent storage.
    # Thread-safe to handle concurrent requests.
    class NonceManager
      # Error for nonce-related issues
      class NonceError < AtprotoAuth::Error; end

      # Represents a stored nonce with its server URL
      class StoredNonce
        attr_reader :value, :server_url, :timestamp

        def initialize(value, server_url, timestamp: nil)
          @value = value
          @server_url = server_url
          @timestamp = timestamp || Time.now.to_i
        end
      end

      # Default time in seconds a nonce is considered valid
      DEFAULT_TTL = 300 # 5 minutes

      def initialize(ttl: nil)
        @ttl = ttl || DEFAULT_TTL
        @serializer = Serialization::StoredNonce.new
      end

      # Updates the stored nonce for a server
      # @param nonce [String] The new nonce value
      # @param server_url [String] The server's URL
      # @raise [NonceError] if inputs are invalid
      def update(nonce:, server_url:)
        validate_inputs!(nonce, server_url)
        origin = normalize_server_url(server_url)

        stored_nonce = StoredNonce.new(nonce, origin)
        serialized = @serializer.serialize(stored_nonce)

        key = Storage::KeyBuilder.nonce_key(origin)
        return if AtprotoAuth.storage.set(key, serialized, ttl: @ttl)

        raise NonceError, "Failed to store nonce"
      end

      # Gets the current nonce for a server
      # @param server_url [String] The server's URL
      # @return [String, nil] The current nonce or nil if none exists/expired
      # @raise [NonceError] if server_url is invalid
      def get(server_url)
        validate_server_url!(server_url)
        origin = normalize_server_url(server_url)
        key = Storage::KeyBuilder.nonce_key(origin)

        stored = AtprotoAuth.storage.get(key)
        return nil unless stored

        begin
          stored_nonce = @serializer.deserialize(stored)
          stored_nonce.value
        rescue Serialization::Error => e
          raise NonceError, "Failed to deserialize nonce: #{e.message}"
        end
      end

      # Clears a nonce for a server
      # @param server_url [String] The server's URL
      def clear(server_url)
        validate_server_url!(server_url)
        origin = normalize_server_url(server_url)
        key = Storage::KeyBuilder.nonce_key(origin)
        AtprotoAuth.storage.delete(key)
      end

      # Check if a server has a valid nonce
      # @param server_url [String] The server's URL
      # @return [Boolean] true if server has a valid nonce
      def valid_nonce?(server_url)
        validate_server_url!(server_url)
        origin = normalize_server_url(server_url)
        key = Storage::KeyBuilder.nonce_key(origin)
        AtprotoAuth.storage.exists?(key)
      end

      private

      def normalize_server_url(url)
        uri = URI(url)
        port = uri.port
        port = nil if (uri.scheme == "https" && port == 443) ||
                      (uri.scheme == "http" && port == 80)

        origin = "#{uri.scheme}://#{uri.host}"
        origin = "#{origin}:#{port}" if port
        origin
      end

      def validate_inputs!(nonce, server_url)
        raise NonceError, "nonce is required" if nonce.nil? || nonce.empty?

        validate_server_url!(server_url)
      end

      def validate_server_url!(server_url)
        raise NonceError, "server_url is required" if server_url.nil? || server_url.empty?

        uri = URI(server_url)
        raise NonceError, "server_url must be HTTP(S)" unless uri.is_a?(URI::HTTP)

        # Allow HTTP for localhost only
        if uri.host != "localhost" && uri.scheme != "https"
          raise NonceError, "server_url must be HTTPS (except for localhost)"
        end
      rescue URI::InvalidURIError => e
        raise NonceError, "invalid server_url: #{e.message}"
      end
    end
  end
end
-----

lib/atproto_auth/dpop/proof_generator.rb:
# frozen_string_literal: true

require "securerandom"
require "time"

module AtprotoAuth
  module DPoP
    # Creates and manages DPoP proof JWTs according to RFC 9449.
    # DPoP proofs are used to prove possession of a key when making
    # HTTP requests. Each proof is a JWT that includes details about
    # the request and is signed by the DPoP key.
    class ProofGenerator
      # Error raised for proof generation/validation issues
      class ProofError < AtprotoAuth::Error; end

      # @return [KeyManager] The key manager used for signing proofs
      attr_reader :key_manager

      # Creates a new ProofGenerator instance
      # @param key_manager [KeyManager] Key manager to use for signing proofs
      # @raise [ProofError] if key_manager is invalid
      def initialize(key_manager)
        raise ProofError, "key_manager is required" unless key_manager
        raise ProofError, "invalid key_manager type" unless key_manager.is_a?(KeyManager)

        @key_manager = key_manager
      end

      # Generates a new DPoP proof JWT for an HTTP request
      # @param http_method [String] HTTP method (e.g. "POST")
      # @param http_uri [String] Full HTTP URI for the request
      # @param nonce [String, nil] Server-provided nonce (required if available)
      # @param access_token [String, nil] Access token being used (if any)
      # @param ath [Boolean] Whether to include access token hash (default: true if token provided)
      # @return [String] The signed DPoP proof JWT
      # @raise [ProofError] if generation fails or parameters are invalid
      def generate(http_method:, http_uri:, nonce: nil, access_token: nil, ath: nil)
        validate_inputs!(http_method, http_uri)
        ath = !access_token.nil? if ath.nil?

        header = build_header
        payload = build_payload(
          http_method: http_method,
          http_uri: http_uri,
          nonce: nonce,
          access_token: access_token,
          include_ath: ath
        )

        key_manager.sign_segments(header, payload)
      rescue StandardError => e
        raise ProofError, "Failed to generate proof: #{e.message}"
      end

      private

      def validate_inputs!(http_method, http_uri)
        raise ProofError, "http_method is required" if http_method.nil? || http_method.empty?
        raise ProofError, "http_uri is required" if http_uri.nil? || http_uri.empty?

        uri = URI(http_uri)
        raise ProofError, "invalid http_uri" unless uri.is_a?(URI::HTTP)
      rescue URI::InvalidURIError => e
        raise ProofError, "invalid http_uri: #{e.message}"
      end

      def build_header
        {
          typ: "dpop+jwt",
          alg: "ES256",
          jwk: key_manager.public_jwk.to_h
        }
      end

      def build_payload(http_method:, http_uri:, nonce: nil, access_token: nil, include_ath: nil)
        payload = {
          "jti" => SecureRandom.uuid,
          "htm" => http_method.upcase,
          "htu" => normalize_uri(http_uri),
          "iat" => Time.now.to_i
        }

        # Add the nonce if provided
        payload["nonce"] = nonce if nonce

        # Add access token hash if needed
        payload["ath"] = generate_access_token_hash(access_token) if access_token && include_ath

        payload
      end

      def normalize_uri(uri)
        uri = URI(uri)
        # Remove default ports
        uri.port = nil if (uri.scheme == "https" && uri.port == 443) || (uri.scheme == "http" && uri.port == 80)
        uri.fragment = nil
        uri.to_s
      end

      def generate_access_token_hash(access_token)
        digest = OpenSSL::Digest::SHA256.digest(access_token)
        Base64.urlsafe_encode64(digest[0...(digest.length / 2)], padding: false)
      end

      def encode_jwt_segments(header, payload)
        encoded_header = Base64.urlsafe_encode64(JSON.generate(header), padding: false)
        encoded_payload = Base64.urlsafe_encode64(JSON.generate(payload), padding: false)
        "#{encoded_header}.#{encoded_payload}"
      end
    end
  end
end
-----

lib/atproto_auth/encryption.rb:
# frozen_string_literal: true

# lib/atproto_auth/encryption.rb
module AtprotoAuth
  module Encryption
    class Error < AtprotoAuth::Error; end
    class ConfigurationError < Error; end
    class EncryptionError < Error; end
    class DecryptionError < Error; end

    # HKDF implementation based on RFC 5869
    module HKDF
      def self.derive(secret, salt:, info:, length:)
        # 1. extract
        prk = OpenSSL::HMAC.digest(
          OpenSSL::Digest.new("SHA256"),
          salt.empty? ? "\x00" * 32 : salt,
          secret.to_s
        )

        # 2. expand
        n = (length.to_f / 32).ceil
        t = [""]
        output = ""
        1.upto(n) do |i|
          t[i] = OpenSSL::HMAC.digest(
            OpenSSL::Digest.new("SHA256"),
            prk,
            t[i - 1] + info + [i].pack("C")
          )
          output += t[i]
        end
        output[0, length]
      end
    end

    # Core encryption service - used internally by serializers
    class Service
      CIPHER = "aes-256-gcm"
      VERSION = 1

      def initialize
        @key_provider = KeyProvider.new
      end

      def encrypt(data, context:)
        validate_encryption_inputs!(data, context)

        iv = SecureRandom.random_bytes(12)

        cipher = OpenSSL::Cipher.new(CIPHER)
        cipher.encrypt
        cipher.key = @key_provider.key_for_context(context)
        cipher.iv = iv
        cipher.auth_data = context.to_s

        encrypted = cipher.update(data.to_s) + cipher.final
        auth_tag = cipher.auth_tag

        {
          version: VERSION,
          iv: Base64.strict_encode64(iv),
          data: Base64.strict_encode64(encrypted),
          tag: Base64.strict_encode64(auth_tag)
        }
      rescue StandardError => e
        raise EncryptionError, "Encryption failed: #{e.message}"
      end

      def decrypt(encrypted, context:)
        validate_decryption_inputs!(encrypted, context)
        validate_encrypted_data!(encrypted)

        iv = Base64.strict_decode64(encrypted[:iv])
        data = Base64.strict_decode64(encrypted[:data])
        auth_tag = Base64.strict_decode64(encrypted[:tag])

        cipher = OpenSSL::Cipher.new(CIPHER)
        cipher.decrypt
        cipher.key = @key_provider.key_for_context(context)
        cipher.iv = iv
        cipher.auth_tag = auth_tag
        cipher.auth_data = context.to_s

        cipher.update(data) + cipher.final
      rescue ArgumentError => e
        raise DecryptionError, "Invalid encrypted data format: #{e.message}"
      rescue StandardError => e
        raise DecryptionError, "Decryption failed: #{e.message}"
      end

      private

      def validate_encryption_inputs!(data, context)
        raise EncryptionError, "Data cannot be nil" if data.nil?
        raise EncryptionError, "Context cannot be nil" if context.nil?
        raise EncryptionError, "Context must be a string" unless context.is_a?(String)
        raise EncryptionError, "Context cannot be empty" if context.empty?
      end

      def validate_decryption_inputs!(encrypted, context)
        raise DecryptionError, "Encrypted data cannot be nil" if encrypted.nil?
        raise DecryptionError, "Context cannot be nil" if context.nil?
        raise DecryptionError, "Context must be a string" unless context.is_a?(String)
        raise DecryptionError, "Context cannot be empty" if context.empty?
      end

      def validate_encrypted_data!(encrypted)
        raise DecryptionError, "Invalid encrypted data format" unless encrypted.is_a?(Hash)

        unless encrypted[:version] == VERSION
          raise DecryptionError, "Unsupported encryption version: #{encrypted[:version]}"
        end

        %i[iv data tag].each do |field|
          raise DecryptionError, "Missing required field: #{field}" unless encrypted[field].is_a?(String)
        end
      end
    end

    # Handles key management and derivation
    class KeyProvider
      def initialize
        @master_key = load_master_key
      end

      def key_for_context(context)
        raise ConfigurationError, "Context is required" if context.nil?

        HKDF.derive(
          @master_key,
          salt: salt_for_context(context),
          info: "atproto-#{context}",
          length: 32
        )
      end

      private

      def load_master_key
        # Try environment variable first
        key = ENV.fetch("ATPROTO_MASTER_KEY", nil)
        return Base64.strict_decode64(key) if key

        # Generate and store a random key if not configured
        key = SecureRandom.random_bytes(32)
        warn "WARNING: Using randomly generated encryption key - tokens will not persist across restarts"
        key
      end

      def salt_for_context(context)
        OpenSSL::Digest.digest("SHA256", "atproto-salt-#{context}")
      end
    end
  end
end
-----

lib/atproto_auth/errors.rb:
# frozen_string_literal: true

module AtprotoAuth
  class Error < StandardError; end

  # Base class for AT Protocol OAuth errors
  class OAuthError < Error
    attr_reader :error_code

    def initialize(message, error_code)
      @error_code = error_code
      # @type-ignore
      super(message)
    end
  end

  # Error raised when client metadata is invalid or cannot be retrieved.
  # This can occur during client metadata fetching, parsing, or validation.
  #
  # @example Handling client metadata errors
  #   begin
  #     client = AtprotoAuth::Client.new(client_id: "https://myapp.com/metadata.json")
  #   rescue AtprotoAuth::InvalidClientMetadata => e
  #     puts "Failed to validate client metadata: #{e.message}"
  #   end
  class InvalidClientMetadata < OAuthError
    def initialize(message)
      super(message, "invalid_client_metadata")
    end
  end

  # Error raised when authorization server metadata is invalid or cannot be retrieved.
  # This includes issues with server metadata fetching, parsing, or validation against
  # the AT Protocol OAuth requirements.
  #
  # @example Handling authorization server errors
  #   begin
  #     server = AtprotoAuth::AuthorizationServer.new(issuer: "https://auth.example.com")
  #   rescue AtprotoAuth::InvalidAuthorizationServer => e
  #     puts "Failed to validate authorization server: #{e.message}"
  #   end
  class InvalidAuthorizationServer < OAuthError
    def initialize(message)
      super(message, "invalid_authorization_server")
    end
  end
end
-----

lib/atproto_auth/http_client.rb:
# frozen_string_literal: true

require "net/http"
require "uri"
require "ipaddr"

module AtprotoAuth
  # A secure HTTP client for making OAuth-related requests.
  # Implements protections against SSRF attacks and enforces security headers.
  class HttpClient
    FORBIDDEN_IP_RANGES = [
      IPAddr.new("0.0.0.0/8"),      # Current network
      IPAddr.new("10.0.0.0/8"),     # Private network
      IPAddr.new("127.0.0.0/8"),    # Loopback
      IPAddr.new("169.254.0.0/16"), # Link-local
      IPAddr.new("172.16.0.0/12"),  # Private network
      IPAddr.new("192.168.0.0/16"), # Private network
      IPAddr.new("fc00::/7"),       # Unique local address
      IPAddr.new("fe80::/10")       # Link-local address
    ].freeze

    ALLOWED_SCHEMES = ["https"].freeze
    DEFAULT_TIMEOUT = 10 # seconds
    MAX_REDIRECTS = 5
    MAX_RESPONSE_SIZE = 10 * 1024 * 1024 # 10MB

    # Error raised when a request is blocked due to SSRF protection
    class SSRFError < Error; end

    # Error raised when an HTTP request fails
    class HttpError < Error
      attr_reader :response

      def initialize(message, response)
        @response = response
        super(message)
      end
    end

    RedirectHandlerOptions = Data.define(:original_uri, :method, :response, :headers, :redirect_count, :body)

    # @param timeout [Integer] Request timeout in seconds
    # @param verify_ssl [Boolean] Whether to verify SSL certificates
    def initialize(timeout: DEFAULT_TIMEOUT, verify_ssl: true)
      @timeout = timeout
      @verify_ssl = verify_ssl
    end

    # Makes a secure HTTP GET request
    # @param url [String] URL to request
    # @param headers [Hash] Additional headers to send
    # @return [Hash] Response with :status, :headers, and :body
    # @raise [SSRFError] If the request would be unsafe
    # @raise [HttpError] If the request fails
    def get(url, headers = {})
      uri = validate_uri!(url)
      validate_ip!(uri)

      response = make_request(uri, headers)
      validate_response!(response)

      {
        status: response.code.to_i,
        headers: response.each_header.to_h,
        body: response.body
      }
    end

    # Makes a secure HTTP POST request
    # @param url [String] URL to request
    # @param body [String] Request body
    # @param headers [Hash] Additional headers to send
    # @return [Hash] Response with :status, :headers, and :body
    # @raise [SSRFError] If the request would be unsafe
    # @raise [HttpError] If the request fails
    def post(url, body: nil, headers: {})
      uri = validate_uri!(url)
      validate_ip!(uri)

      response = make_post_request(uri, body, headers)
      validate_response!(response)

      {
        status: response.code.to_i,
        headers: response.each_header.to_h,
        body: response.body
      }
    end

    private

    def validate_uri!(url)
      uri = URI(url)
      unless ALLOWED_SCHEMES.include?(uri.scheme)
        raise SSRFError, "URL scheme must be one of: #{ALLOWED_SCHEMES.join(", ")}"
      end
      raise SSRFError, "URL must include host" unless uri.host
      raise SSRFError, "URL must not include fragment" if uri.fragment

      uri
    end

    def validate_ip!(uri)
      ip = resolve_ip(uri.host)
      return unless forbidden_ip?(ip)

      raise SSRFError, "Request to forbidden IP address"
    end

    def resolve_ip(hostname)
      IPAddr.new(Addrinfo.ip(hostname).ip_address)
    rescue SocketError => e
      raise SSRFError, "Failed to resolve hostname: #{e.message}"
    end

    def forbidden_ip?(ip)
      FORBIDDEN_IP_RANGES.any? { |range| range.include?(ip) }
    end

    def make_request(uri, headers = {}, redirect_count = 0)
      http = Net::HTTP.new(uri.host, uri.port)
      configure_http_client!(http)

      request = Net::HTTP::Get.new(uri.request_uri)
      add_security_headers!(request, headers)
      response = http.request(request)
      handle_redirect(
        original_uri: uri,
        response: response,
        headers: headers,
        redirect_count: redirect_count
      )
    rescue Net::OpenTimeout, Net::ReadTimeout => e
      raise HttpError.new("Request timeout: #{e.message}", nil)
    rescue StandardError => e
      raise HttpError.new("Request failed: #{e.message}", nil)
    end

    def make_post_request(uri, body, headers = {}, redirect_count = 0)
      http = Net::HTTP.new(uri.host, uri.port)
      configure_http_client!(http)

      request = Net::HTTP::Post.new(uri.request_uri)
      add_security_headers!(request, headers)
      request.body = body.is_a?(Hash) ? URI.encode_www_form(body) : body if body

      response = http.request(request)
      handle_redirect(
        original_uri: uri,
        body: body,
        method: :post,
        response: response,
        headers: headers,
        redirect_count: redirect_count
      )
    rescue Net::OpenTimeout, Net::ReadTimeout => e
      raise HttpError.new("Request timeout: #{e.message}", nil)
    rescue StandardError => e
      raise HttpError.new("Request failed: #{e.message}", nil)
    end

    def configure_http_client!(http)
      http.use_ssl = true
      http.verify_mode = @verify_ssl ? OpenSSL::SSL::VERIFY_PEER : OpenSSL::SSL::VERIFY_NONE
      http.read_timeout = @timeout
      http.open_timeout = @timeout
    end

    def add_security_headers!(request, headers)
      # Prevent caching of sensitive data
      request["Cache-Control"] = "no-store"

      # Add user-provided headers
      headers.each { |k, v| request[k] = v }
    end

    # Handle HTTP redirects
    # kwargs can include:
    # - original_uri: URI of the original request
    # - method: HTTP method of the original request (:get or :post)
    # - response: Net::HTTPResponse object
    # - headers: Hash of headers from the original request
    # - redirect_count: Number of redirects so far
    # - body: Request body for POST requests
    def handle_redirect(**kwargs)
      response = kwargs[:response]
      redirect_count = kwargs[:redirect_count]

      return response unless response.is_a?(Net::HTTPRedirection)
      raise HttpError.new("Too many redirects", response) if redirect_count >= MAX_REDIRECTS

      location = URI(response["location"])
      location = kwargs[:original_uri] + location if location.relative?

      validate_uri!(location.to_s)
      validate_ip!(location)

      # Increment redirect count for the next request
      redirect_count += 1

      # Recursive call to handle the next redirect
      if kwargs[:method] == :post
        make_post_request(location, kwargs[:body], kwargs[:headers], redirect_count)
      else
        make_request(location, kwargs[:headers], redirect_count)
      end
    end

    def validate_response!(response)
      # check_success_status!(response)
      check_content_length!(response)
    end

    def check_success_status!(response)
      return if response.is_a?(Net::HTTPSuccess)

      raise HttpError.new("HTTP request failed: #{response.code} #{response.message}", response)
    end

    def check_content_length!(response)
      content_length = response["content-length"]&.to_i || response.body&.bytesize || 0
      return unless content_length > MAX_RESPONSE_SIZE

      raise HttpError.new("Response too large: #{content_length} bytes", response)
    end
  end
end
-----

lib/atproto_auth/identity/document.rb:
# frozen_string_literal: true

module AtprotoAuth
  module Identity
    # Represents and validates a DID Document in the AT Protocol.
    #
    # DID Documents contain critical service information about user accounts, including:
    # - The Personal Data Server (PDS) hosting the account
    # - Associated handles for the account
    # - Key material for identity verification
    # - Service endpoints for various protocols
    #
    # This class handles both current and legacy DID document formats, providing
    # a consistent interface for accessing and validating document data.
    #
    # @example Creating a document from JSON
    #   data = {
    #     "id" => "did:plc:abc123",
    #     "alsoKnownAs" => ["at://alice.example.com"],
    #     "pds" => "https://pds.example.com"
    #   }
    #   doc = AtprotoAuth::Identity::Document.new(data)
    #
    #   puts doc.pds                    # => "https://pds.example.com"
    #   puts doc.has_handle?("alice.example.com")  # => true
    #
    # @example Handling legacy format
    #   legacy_data = {
    #     "id" => "did:plc:abc123",
    #     "service" => [{
    #       "id" => "#atproto_pds",
    #       "type" => "AtprotoPersonalDataServer",
    #       "serviceEndpoint" => "https://pds.example.com"
    #     }]
    #   }
    #   doc = AtprotoAuth::Identity::Document.new(legacy_data)
    #   puts doc.pds  # => "https://pds.example.com"
    class Document
      attr_reader :did, :rotation_keys, :also_known_as, :services, :pds

      # Creates a new Document from parsed JSON
      # @param data [Hash] Parsed DID document data
      # @raise [DocumentError] if document is invalid
      def initialize(data)
        validate_document!(data)

        @did = data["id"]
        @rotation_keys = data["verificationMethod"]&.map { |m| m["publicKeyMultibase"] } || []
        @also_known_as = data["alsoKnownAs"] || []
        @services = data["service"] || []
        @pds = extract_pds!(data)
      end

      # Checks if this document contains a specific handle
      # @param handle [String] Handle to check (with or without @ prefix)
      # @return [Boolean] true if handle is listed in alsoKnownAs
      def has_handle?(handle) # rubocop:disable Naming/PredicateName
        normalized = handle.start_with?("@") ? handle[1..] : handle
        @also_known_as.any? do |aka|
          aka.start_with?("at://") && aka.delete_prefix("at://") == normalized
        end
      end

      private

      def validate_document!(data)
        raise DocumentError, "Document cannot be nil" if data.nil?
        raise DocumentError, "Document must be a Hash" unless data.is_a?(Hash)
        raise DocumentError, "Document must have id" unless data["id"]

        validate_did!(data["id"])
        validate_services!(data["service"])
      end

      def validate_did!(did)
        return if did.start_with?("did:plc:")

        raise DocumentError, "Invalid DID format (must be did:plc:): #{did}"
      end

      def validate_services!(services)
        return if services.nil?
        raise DocumentError, "services must be an array" unless services.is_a?(Array)

        services.each do |svc|
          unless svc.is_a?(Hash) && svc["id"] && svc["type"] && svc["serviceEndpoint"]
            raise DocumentError, "Invalid service entry format"
          end
        end
      end

      def extract_pds!(data)
        pds = data["pds"] # New format
        return pds if pds

        # Legacy format - look through services
        service = @services.find { |s| s["type"] == "AtprotoPersonalDataServer" }
        raise DocumentError, "No PDS location found in document" unless service

        service["serviceEndpoint"]
      end
    end
  end
end
-----

lib/atproto_auth/identity/resolver.rb:
# frozen_string_literal: true

require "resolv"

module AtprotoAuth
  module Identity
    # Resolves and validates AT Protocol identities
    class Resolver
      PLC_DIRECTORY_URL = "https://plc.directory"
      DID_PLC_PREFIX = "did:plc:"
      HANDLE_REGEX = /^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$/

      # Creates a new Identity resolver
      # @param plc_directory [String] Optional custom PLC directory URL
      def initialize(plc_directory: nil)
        @plc_directory = plc_directory || PLC_DIRECTORY_URL
      end

      # Resolves a handle to a DID Document
      # @param handle [String] The handle to resolve (with or without @ prefix)
      # @return [Hash] Resolution result with :did, :document, and :pds keys
      # @raise [ResolutionError] if resolution fails
      def resolve_handle(handle)
        validate_handle!(handle)
        normalized = normalize_handle(handle)

        # First try DNS-based resolution
        did = resolve_handle_dns(normalized)
        return get_did_info(did) if did

        # Fall back to HTTP resolution via a known PDS
        resolve_handle_http(normalized)
      rescue StandardError => e
        raise ResolutionError, "Failed to resolve handle #{handle}: #{e.message}"
      end

      # Fetches and parses DID Document
      # @param did [String] The DID to resolve
      # @return [Hash] Resolution result with :did, :document, and :pds keys
      # @raise [ResolutionError] if resolution fails
      def get_did_info(did)
        validate_did!(did)

        # Fetch and parse DID document
        doc_data = fetch_did_document(did)
        document = Document.new(doc_data)

        # Validate PDS URL format
        validate_pds_url!(document.pds)

        { did: did, document: document, pds: document.pds }
      rescue DocumentError => e
        raise ResolutionError, "Invalid DID document: #{e.message}"
      rescue StandardError => e
        raise ResolutionError, "Failed to resolve DID #{did}: #{e.message}"
      end

      # Verifies that a PDS hosts a given DID
      # @param did [String] The DID to verify
      # @param pds_url [String] The PDS URL to check
      # @return [Boolean] true if verification succeeds
      # @raise [ValidationError] if verification fails
      def verify_pds_binding(did, pds_url)
        info = get_did_info(did)
        normalize_url(info[:pds]) == normalize_url(pds_url)
      rescue StandardError => e
        raise ValidationError, "Failed to verify PDS binding: #{e.message}"
      end

      # Verifies that an auth server (issuer) is authorized for a DID
      # @param did [String] The DID to verify
      # @param issuer [String] The issuer URL to verify
      # @return [Boolean] true if verification succeeds
      # @raise [ValidationError] if verification fails
      def verify_issuer_binding(did, issuer)
        # Get PDS location from DID
        info = get_did_info(did)
        pds_url = info[:pds]

        # Fetch resource server metadata to find auth server
        resource_server = ServerMetadata::ResourceServer.from_url(pds_url)
        auth_server_url = resource_server.authorization_servers.first

        # Compare normalized URLs
        normalize_url(auth_server_url) == normalize_url(issuer)
      rescue StandardError => e
        raise ValidationError, "Failed to verify issuer binding: #{e.message}"
      end

      # Verifies that a handle belongs to a DID
      # @param handle [String] Handle to verify
      # @param did [String] DID to check against
      # @return [Boolean] true if verification succeeds
      # @raise [ValidationError] if verification fails
      def verify_handle_binding(handle, did)
        info = get_did_info(did)
        info[:document].has_handle?(handle)
      rescue StandardError => e
        raise ValidationError, "Failed to verify handle binding: #{e.message}"
      end

      private

      def validate_handle!(handle)
        normalized = normalize_handle(handle)
        return if normalized.match?(HANDLE_REGEX)

        raise ResolutionError, "Invalid handle format: #{handle}"
      end

      def validate_did!(did)
        return if did.start_with?(DID_PLC_PREFIX)

        raise ResolutionError, "Invalid DID format (must be did:plc:): #{did}"
      end

      def normalize_handle(handle)
        normalized = handle.start_with?("@") ? handle[1..] : handle
        normalized.downcase
      end

      def resolve_handle_dns(handle)
        domain = extract_domain(handle)
        return nil unless domain

        txt_records = fetch_txt_records("_atproto.#{domain}")
        return nil unless txt_records&.any?

        # Look for did= entries in TXT records
        txt_records.each do |record|
          next unless record.start_with?("did=")

          did = record.delete_prefix("did=").strip
          return did if valid_did?(did)
        end

        nil
      rescue Resolv::ResolvError, Resolv::ResolvTimeout => e
        logger.debug("DNS resolution failed for #{handle}: #{e.message}")
        nil # Gracefully fall back to HTTP resolution
      end

      def extract_domain(handle)
        # Remove @ prefix if present
        handle = handle[1..] if handle.start_with?("@")

        # Handle could be user.domain.com or domain.com format
        # We just need the domain portion
        if handle.count(".") == 1
          handle
        else
          handle.split(".", 2)[1]
        end
      end

      def fetch_txt_records(domain)
        resolver = Resolv::DNS.new
        resolver.timeouts = 3 # 3 second timeout

        records = resolver.getresources(
          domain,
          Resolv::DNS::Resource::IN::TXT
        ).map { |r| r.strings.join(" ") }

        resolver.close
        records
      end

      def valid_did?(did)
        did.start_with?(DID_PLC_PREFIX) && did.length > DID_PLC_PREFIX.length
      end

      def resolve_handle_http(handle)
        # Build resolution URL
        uri = URI("https://#{handle}/.well-known/atproto-did")

        # Make HTTP request
        response = AtprotoAuth.configuration.http_client.get(uri.to_s)
        did = response[:body].strip

        validate_did!(did)
        get_did_info(did)
      end

      def fetch_did_document(did)
        # Fetch document from PLC directory
        uri = URI.join(@plc_directory, "/#{did}")
        response = AtprotoAuth.configuration.http_client.get(uri.to_s)
        JSON.parse(response[:body])
      end

      def validate_pds_url!(url)
        uri = URI(url)
        return if uri.is_a?(URI::HTTPS)

        raise ResolutionError, "PDS URL must use HTTPS"
      end

      def normalize_url(url)
        uri = URI(url)

        # Remove default ports
        uri.port = nil if (uri.scheme == "https" && uri.port == 443) ||
                          (uri.scheme == "http" && uri.port == 80)

        # Ensure no trailing slash
        uri.path = uri.path.chomp("/")

        # Remove any query or fragment
        uri.query = nil
        uri.fragment = nil

        uri.to_s
      end

      def logger
        @logger ||= AtprotoAuth.configuration.logger || Logger.new($stdout)
      end
    end
  end
end
-----

lib/atproto_auth/identity.rb:
# frozen_string_literal: true

module AtprotoAuth
  # Handles identity resolution, verification and management for AT Protocol OAuth.
  # This module provides functionality to resolve handles to DIDs, verify identity
  # documents, validate PDS locations, and verify authorization server bindings.
  #
  # The module consists of three main components:
  #
  # 1. {Document} - Represents and validates AT Protocol DID documents,
  #    handling extraction of crucial service endpoints and verification.
  #
  # 2. {Resolver} - Handles resolution of handles to DIDs and fetching of
  #    DID documents, with support for both DNS and HTTP-based resolution.
  #
  # 3. {Error} classes - Structured error hierarchy for handling different
  #    types of identity-related failures.
  module Identity
    class Error < Error; end
    class ResolutionError < Error; end
    class ValidationError < Error; end
    class DocumentError < Error; end
  end
end
-----

lib/atproto_auth/par/client.rb:
# frozen_string_literal: true

module AtprotoAuth
  module PAR
    # Client for making Pushed Authorization Requests (PAR) according to RFC 9126.
    # Handles submitting authorization parameters to the PAR endpoint and building
    # the subsequent authorization URL.
    #
    # In AT Protocol OAuth, all authorization requests must first go through PAR.
    # This means instead of sending authorization parameters directly to the
    # authorization endpoint, clients:
    # 1. Submit parameters to the PAR endpoint via POST
    # 2. Receive a request_uri in response
    # 3. Use only the request_uri and client_id in the authorization redirect
    #
    # @example Basic PAR flow
    #   client = AtprotoAuth::PAR::Client.new(
    #     endpoint: "https://auth.example.com/par"
    #   )
    #
    #   # Create and submit PAR request using builder pattern
    #   request = AtprotoAuth::PAR::Request.build do |config|
    #     config.client_id = "https://app.example.com/client-metadata.json"
    #     config.redirect_uri = "https://app.example.com/callback"
    #     config.code_challenge = "abc123..."
    #     config.code_challenge_method = "S256"
    #     config.state = "xyz789..."
    #     config.scope = "atproto"
    #   end
    #
    #   response = client.submit(request)
    #
    #   # Build authorization URL using response
    #   auth_url = client.authorization_url(
    #     authorize_endpoint: "https://auth.example.com/authorize",
    #     request_uri: response.request_uri,
    #     client_id: request.client_id
    #   )
    #
    # @example With client authentication (confidential clients)
    #   request = AtprotoAuth::PAR::Request.build do |config|
    #     # ... basic parameters ...
    #     config.client_assertion_type = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
    #     config.client_assertion = jwt_token
    #   end
    #
    # @example With DPoP proof
    #   request = AtprotoAuth::PAR::Request.build do |config|
    #     # ... basic parameters ...
    #     config.dpop_proof = dpop_proof_jwt
    #   end
    #
    # All requests are made using HTTPS and include proper content-type headers.
    # DPoP proofs can be included for enhanced security. The client validates
    # all responses and provides clear error messages for any failures.
    class Client
      attr_reader :endpoint, :dpop_client, :nonce_manager

      def initialize(endpoint:, dpop_client:)
        @endpoint = endpoint
        @dpop_client = dpop_client
        @nonce_manager = dpop_client.nonce_manager
        validate_endpoint!
      end

      # Submits a PAR request, handling DPoP nonce requirements
      # @param request [Request] The request to submit
      # @return [Response] The PAR response
      # @raise [Error] if request fails
      def submit(request)
        # Try the initial request
        response = make_request(request)

        return process_response(response) if response[:status] == 201

        # Handle DPoP nonce requirement
        if requires_nonce?(response)
          nonce = extract_nonce(response)
          store_nonce(nonce)

          # Get stored nonce to verify
          nonce_manager.get(server_origin)

          # Generate new proof with nonce and retry
          response = make_request(request)
          return process_response(response) if response[:status] == 201
        end

        handle_error_response(response)
      rescue StandardError => e
        raise Error, "PAR request failed: #{e.message}"
      end

      def extract_nonce(response)
        # Try all possible header key formats
        headers = response[:headers]
        nonce = headers["DPoP-Nonce"] ||
                headers["dpop-nonce"] ||
                headers["Dpop-Nonce"]

        raise Error, "No DPoP nonce provided in response" unless nonce

        nonce
      end

      # Builds authorization URL from PAR response
      # @param authorize_endpoint [String] Authorization endpoint URL
      # @param request_uri [String] PAR request_uri
      # @param client_id [String] OAuth client_id
      # @return [String] Authorization URL
      def authorization_url(authorize_endpoint:, request_uri:, client_id:)
        uri = URI(authorize_endpoint)
        uri.query = encode_params(
          "request_uri" => request_uri,
          "client_id" => client_id
        )
        uri.to_s
      end

      private

      def validate_endpoint!
        uri = URI(@endpoint)
        raise Error, "endpoint must be HTTPS" unless uri.scheme == "https"
      rescue URI::InvalidURIError => e
        raise Error, "invalid endpoint URL: #{e.message}"
      end

      def make_request(request)
        # Generate DPoP proof for this request
        proof = dpop_client.generate_proof(
          http_method: "POST",
          http_uri: endpoint,
          nonce: nonce_manager.get(server_origin)
        )

        # Build headers including DPoP proof
        headers = build_headers(request, proof)

        # Make the request
        AtprotoAuth.configuration.http_client.post(
          endpoint,
          body: request.to_form,
          headers: headers
        )
      end

      def build_headers(_request, dpop_proof)
        {
          "Content-Type" => "application/x-www-form-urlencoded",
          "DPoP" => dpop_proof
        }
      end

      def requires_nonce?(response)
        body = JSON.parse(response[:body])
        body["error"] == "use_dpop_nonce"
      rescue JSON::ParserError
        false
      end

      def store_nonce(nonce)
        nonce_manager.update(nonce: nonce, server_url: server_origin)
      end

      def server_origin
        uri = URI(@endpoint)
        "#{uri.scheme}://#{uri.host}#{":#{uri.port}" if uri.port != uri.default_port}"
      end

      def handle_error_response(response)
        begin
          error_data = JSON.parse(response[:body])
          error_message = error_data["error_description"] || error_data["error"] || "Unknown error"
        rescue JSON::ParserError
          error_message = "Invalid response from server"
        end

        raise Error, "PAR request failed: #{error_message} (status: #{response[:status]})"
      end

      def process_response(response)
        raise Error, "unexpected response status: #{response[:status]}" unless response[:status] == 201

        begin
          data = JSON.parse(response[:body])
          Response.new(
            request_uri: data["request_uri"],
            expires_in: data["expires_in"]
          )
        rescue JSON::ParserError => e
          raise Error, "invalid JSON response: #{e.message}"
        rescue StandardError => e
          raise Error, "failed to process response: #{e.message}"
        end
      end

      def encode_params(params)
        params.map { |k, v| "#{CGI.escape(k)}=#{CGI.escape(v.to_s)}" }.join("&")
      end
    end
  end
end
-----

lib/atproto_auth/par/client_assertion.rb:
# frozen_string_literal: true

module AtprotoAuth
  module PAR
    # Generates client authentication JWTs according to RFC 7523 for AT Protocol OAuth.
    # Creates signed assertions using ES256 with required claims including iss/sub (client_id),
    # aud (token endpoint), jti (unique ID), and iat/exp (timing claims).
    class ClientAssertion
      class Error < AtprotoAuth::Error; end

      # @param client_id [String] OAuth client ID
      # @param signing_key [JOSE::JWK] Key to sign assertion with
      def initialize(client_id:, signing_key:)
        @client_id = client_id
        @signing_key = signing_key
      end

      # Generates a new client assertion JWT
      # @param audience [String] Issuer endpoint URL
      # @param lifetime [Integer] How long assertion is valid for in seconds
      # @return [String] Signed JWT assertion
      # 5 minute default lifetime
      def generate_jwt(audience:, lifetime: 300)
        now = Time.now.to_i

        payload = {
          # Required claims
          iss: @client_id, # Issuer is client_id
          sub: @client_id, # Subject is client_id
          aud: audience, # Audience is token endpoint
          jti: SecureRandom.uuid, # Unique identifier
          exp: now + lifetime, # Expiration time
          iat: now # Issued at time
        }

        # Header specifying ES256 algorithm for signing
        header = {
          alg: "ES256",
          typ: "JWT",
          kid: @signing_key.fields["kid"]
        }

        # Sign and return the JWT
        JWT.encode(payload, @signing_key.kty.key, "ES256", header)
      rescue StandardError => e
        raise Error, "Failed to generate client assertion: #{e.message}"
      end
    end
  end
end
-----

lib/atproto_auth/par/request.rb:
# frozen_string_literal: true

module AtprotoAuth
  module PAR
    # Represents a pushed authorization request
    class Request
      # Configuration for request parameters
      class Configuration
        attr_accessor :client_id, :redirect_uri, :code_challenge,
                      :code_challenge_method, :state, :scope, :login_hint,
                      :nonce, :dpop_proof, :client_assertion_type,
                      :client_assertion
      end

      # Required parameters
      attr_reader :response_type, :client_id, :code_challenge,
                  :code_challenge_method, :state, :redirect_uri, :scope

      # Optional parameters
      attr_reader :login_hint, :nonce, :dpop_proof

      # Client authentication (for confidential clients)
      attr_reader :client_assertion_type, :client_assertion

      def self.build
        config = Configuration.new
        yield(config)
        new(config)
      end

      def initialize(config)
        # Required parameters
        @response_type = "code" # Always "code" for AT Protocol OAuth
        @client_id = config.client_id
        @redirect_uri = config.redirect_uri
        @code_challenge = config.code_challenge
        @code_challenge_method = config.code_challenge_method
        @state = config.state
        @scope = config.scope

        # Optional parameters
        @login_hint = config.login_hint
        @nonce = config.nonce
        @dpop_proof = config.dpop_proof

        # Client authentication
        @client_assertion_type = config.client_assertion_type
        @client_assertion = config.client_assertion

        validate!
      end

      # Converts request to form-encoded parameters
      # @return [String] Form-encoded request body
      def to_form
        encode_params(build_params)
      end

      private

      def build_params
        params = {
          "response_type" => response_type,
          "client_id" => client_id,
          "redirect_uri" => redirect_uri,
          "code_challenge" => code_challenge,
          "code_challenge_method" => code_challenge_method,
          "state" => state,
          "scope" => scope
        }

        add_optional_params(params)
        add_client_auth_params(params)
        params
      end

      def add_optional_params(params)
        params["login_hint"] = login_hint if login_hint
        params["nonce"] = nonce if nonce
      end

      def add_client_auth_params(params)
        return unless client_assertion

        params["client_assertion_type"] = CLIENT_ASSERTION_TYPE
        params["client_assertion"] = client_assertion
      end

      def validate!
        validate_required_params!
        validate_response_type!
        validate_code_challenge_method!
        validate_scope!
        validate_client_auth!
      end

      def validate_required_params!
        %i[client_id redirect_uri code_challenge code_challenge_method state scope].each do |param|
          value = send(param)
          raise Error, "#{param} is required" if value.nil? || value.empty?
        end
      end

      def validate_response_type!
        return if response_type == "code"

        raise Error, "response_type must be 'code'"
      end

      def validate_code_challenge_method!
        return if code_challenge_method == "S256"

        raise Error, "code_challenge_method must be 'S256'"
      end

      def validate_scope!
        scopes = scope.split
        raise Error, "atproto scope is required" unless scopes.include?("atproto")
      end

      def validate_client_auth!
        # If either auth parameter is present, both must be present and valid
        has_assertion = !client_assertion.nil?
        has_type = !client_assertion_type.nil?

        return unless has_assertion || has_type
        unless client_assertion_type == CLIENT_ASSERTION_TYPE
          raise Error, "client_assertion_type must be #{CLIENT_ASSERTION_TYPE}"
        end

        raise Error, "client_assertion required with client_assertion_type" if client_assertion.nil?
        raise Error, "client_assertion_type required with client_assertion" if client_assertion_type.nil?
      end

      def encode_params(params)
        params.map { |k, v| "#{CGI.escape(k)}=#{CGI.escape(v.to_s)}" }.join("&")
      end
    end
  end
end
-----

lib/atproto_auth/par/response.rb:
# frozen_string_literal: true

module AtprotoAuth
  module PAR
    # Represents a PAR response
    class Response
      attr_reader :request_uri, :expires_in

      def initialize(request_uri:, expires_in:)
        @request_uri = request_uri
        @expires_in = expires_in.to_i
        validate!
      end

      private

      def validate!
        raise Error, "request_uri is required" if request_uri.nil? || request_uri.empty?
        raise Error, "expires_in must be positive" unless expires_in.positive?
      end
    end
  end
end
-----

lib/atproto_auth/par.rb:
# frozen_string_literal: true

require "securerandom"
require "base64"
require "openssl"

module AtprotoAuth
  # Handles creation and processing of Pushed Authorization Requests (PAR)
  # according to RFC 9126 and AT Protocol OAuth requirements.
  #
  # PAR is mandatory in AT Protocol OAuth. Before redirecting a user to the
  # authorization endpoint, clients must first submit all authorization parameters
  # via HTTP POST to the PAR endpoint. Only the returned request_uri and client_id
  # are then included in the authorization redirect.
  #
  # @example Basic PAR request
  #   par = AtprotoAuth::PAR::Client.new(endpoint: "https://auth.example.com/par")
  #
  #   request = par.create_request(
  #     client_id: "https://app.example.com/client-metadata.json",
  #     redirect_uri: "https://app.example.com/callback",
  #     code_challenge: "abc123...",
  #     code_challenge_method: "S256",
  #     state: "xyz789...",
  #     scope: "atproto"
  #   )
  #
  #   response = par.submit(request)
  #   auth_url = par.authorization_url(
  #     authorize_endpoint: "https://auth.example.com/authorize",
  #     request_uri: response.request_uri,
  #     client_id: request.client_id
  #   )
  module PAR
    # Error raised for PAR-related issues
    class Error < AtprotoAuth::Error; end

    CLIENT_ASSERTION_TYPE = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
  end
end
-----

lib/atproto_auth/pkce.rb:
# frozen_string_literal: true

require "securerandom"
require "base64"
require "openssl"

module AtprotoAuth
  # Implementation of Proof Key for Code Exchange (PKCE) for OAuth 2.0 / AT Protocol
  # as specified in RFC 7636.
  #
  # This module provides functionality to:
  # - Generate cryptographically secure code verifiers
  # - Create SHA-256 code challenges from verifiers
  # - Verify challenge/verifier pairs
  #
  # Only the S256 challenge method is supported, as required by AT Protocol OAuth.
  module PKCE
    # Error raised for PKCE-related failures
    class Error < AtprotoAuth::Error; end

    # Minimum and maximum lengths for code verifier as per RFC 7636
    MIN_VERIFIER_LENGTH = 43
    MAX_VERIFIER_LENGTH = 128

    # PKCE code verifier charset as per RFC 7636 Section 4.1
    ALLOWED_VERIFIER_CHARS = /^[A-Za-z0-9\-\._~]+$/

    class << self
      # Generates a cryptographically secure random code verifier
      # @param length [Integer] Length of verifier to generate
      # @return [String] The generated code verifier
      # @raise [Error] if length is invalid
      def generate_verifier(length = MAX_VERIFIER_LENGTH)
        validate_verifier_length!(length)

        # Generate random bytes and encode as URL-safe base64
        random_bytes = SecureRandom.random_bytes(length * 3 / 4)
        Base64.urlsafe_encode64(random_bytes, padding: false)[0...length]
      rescue StandardError => e
        raise Error, "Failed to generate verifier: #{e.message}"
      end

      # Creates a code challenge from a verifier using SHA-256
      # @param verifier [String] The code verifier to create challenge from
      # @return [String] Base64URL-encoded SHA-256 hash of the verifier
      # @raise [Error] if verifier is invalid or hashing fails
      def generate_challenge(verifier)
        validate_verifier!(verifier)

        # Hash with SHA-256 and encode as URL-safe base64
        digest = OpenSSL::Digest::SHA256.digest(verifier)
        Base64.urlsafe_encode64(digest, padding: false)
      rescue StandardError => e
        raise Error, "Failed to generate challenge: #{e.message}"
      end

      # Verifies that a challenge matches a verifier
      # @param challenge [String] The code challenge to verify
      # @param verifier [String] The code verifier to check against
      # @return [Boolean] true if challenge matches verifier
      # @raise [Error] if inputs are invalid
      def verify(challenge, verifier)
        # Generate challenge from verifier and compare
        calculated = generate_challenge(verifier)
        secure_compare(calculated, challenge)
      rescue Error
        # Re-raise PKCE errors
        raise
      rescue StandardError => e
        raise Error, "Challenge verification failed: #{e.message}"
      end

      private

      def validate_verifier_length!(length)
        return if length.is_a?(Integer) && length.between?(MIN_VERIFIER_LENGTH, MAX_VERIFIER_LENGTH)

        raise Error, "Verifier length must be between #{MIN_VERIFIER_LENGTH} and #{MAX_VERIFIER_LENGTH}"
      end

      def validate_verifier!(verifier)
        raise Error, "Verifier cannot be nil" if verifier.nil?
        raise Error, "Verifier cannot be empty" if verifier.empty?

        length = verifier.length
        validate_verifier_length!(length)

        return if verifier.match?(ALLOWED_VERIFIER_CHARS)

        raise Error, "Verifier contains invalid characters"
      end

      # Constant-time string comparison to prevent timing attacks
      def secure_compare(str1, str2)
        return false unless str1.bytesize == str2.bytesize

        left = str1.unpack("C*")
        right = str2.unpack("C*")
        result = 0
        left.zip(right) { |x, y| result |= x ^ y }
        result.zero?
      end
    end
  end
end
-----

lib/atproto_auth/serialization/base.rb:
# frozen_string_literal: true

module AtprotoAuth
  module Serialization
    class Error < AtprotoAuth::Error; end

    class VersionError < Error; end

    class TypeMismatchError < Error; end

    class ValidationError < Error; end

    # Base serializer that all type-specific serializers inherit from
    class Base
      CURRENT_VERSION = 1
      SENSITIVE_FIELDS = [
        "access_token",
        "refresh_token",
        "private_key",
        "d", # EC private key component
        "pkce_verifier"
      ].freeze

      class << self
        # Serialize object to storage format
        # @param obj [Object] Object to serialize
        # @return [String] JSON serialized data
        def serialize(obj)
          new.serialize(obj)
        end

        # Deserialize from storage format
        # @param data [String] JSON serialized data
        # @return [Object] Deserialized object
        def deserialize(data)
          new.deserialize(data)
        end
      end

      def initialize
        @encryption = Encryption::Service.new
      end

      # Serialize object to storage format
      # @param obj [Object] Object to serialize
      # @return [String] JSON serialized data
      def serialize(obj)
        validate_object!(obj)

        # First serialize the object
        data = {
          version: CURRENT_VERSION,
          type: type_identifier,
          created_at: Time.now.utc.iso8601,
          updated_at: Time.now.utc.iso8601,
          data: serialize_data(obj)
        }

        # Then encrypt sensitive fields
        encrypt_sensitive_fields!(data)

        # Finally convert to JSON
        JSON.generate(data)
      end

      # Deserialize from storage format
      # @param data [String] JSON serialized data
      # @return [Object] Deserialized object
      def deserialize(data)
        parsed = parse_json(data)
        validate_serialized_data!(parsed)

        # Decrypt sensitive fields
        decrypt_sensitive_fields!(parsed)

        # Deserialize according to version
        deserialize_version(parsed)
      end

      private

      def encrypt_sensitive_fields!(data, path: [])
        return unless data.is_a?(Hash)

        data.each do |key, value|
          current_path = path + [key]

          if sensitive_field?(key)
            data[key] = @encryption.encrypt(
              value.to_s,
              context: current_path.join(".")
            )
          elsif value.is_a?(Hash)
            encrypt_sensitive_fields!(value, path: current_path)
          elsif value.is_a?(Array)
            value.each_with_index do |v, i|
              encrypt_sensitive_fields!(v, path: current_path + [i.to_s]) if v.is_a?(Hash)
            end
          end
        end
      end

      def decrypt_sensitive_fields!(data, path: [])
        return unless data.is_a?(Hash)

        data.each do |key, value|
          current_path = path + [key]
          if sensitive_field?(key)
            data[key] = @encryption.decrypt(
              value.transform_keys(&:to_sym),
              context: current_path.join(".")
            )
          elsif value.is_a?(Hash)
            decrypt_sensitive_fields!(value, path: current_path)
          elsif value.is_a?(Array)
            value.each_with_index do |v, i|
              decrypt_sensitive_fields!(v, path: current_path + [i.to_s]) if v.is_a?(Hash)
            end
          end
        end
      end

      def sensitive_field?(field)
        SENSITIVE_FIELDS.any? do |sensitive_field|
          field.to_s == sensitive_field
        end
      end

      # Type identifier for serialized data
      # @return [String]
      def type_identifier
        raise NotImplementedError
      end

      # Serialize object to hash
      # @param obj [Object] Object to serialize
      # @return [Hash] Serialized data
      def serialize_data(_obj)
        raise NotImplementedError
      end

      # Deserialize object from hash
      # @param data [Hash] Serialized data
      # @return [Object] Deserialized object
      def deserialize_data(_data)
        raise NotImplementedError
      end

      # Validate object before serialization
      # @param obj [Object] Object to validate
      # @raise [ValidationError] if object is invalid
      def validate_object!(_obj)
        raise NotImplementedError
      end

      def parse_json(data)
        JSON.parse(data)
      rescue JSON::ParserError => e
        raise Error, "Invalid JSON data: #{e.message}"
      end

      def validate_serialized_data!(data)
        raise Error, "Invalid serialized data format" unless data.is_a?(Hash)

        unless data["type"] == type_identifier
          raise TypeMismatchError,
                "Expected type #{type_identifier}, got #{data["type"]}"
        end

        raise VersionError, "Invalid version format" unless data["version"].is_a?(Integer)

        return unless data["version"] > CURRENT_VERSION

        raise VersionError,
              "Version #{data["version"]} not supported"
      end

      def deserialize_version(data)
        case data["version"]
        when 1
          deserialize_data(data["data"])
        else
          raise VersionError,
                "Unknown version: #{data["version"]}"
        end
      end
    end
  end
end
-----

lib/atproto_auth/serialization/dpop_key.rb:
# frozen_string_literal: true

module AtprotoAuth
  module Serialization
    # Handles serialization of DPoP keys
    class DPoPKey < Base
      def type_identifier
        "DPoPKey"
      end

      private

      def validate_object!(obj)
        return if obj.is_a?(AtprotoAuth::DPoP::KeyManager)

        raise ValidationError,
              "Expected KeyManager object, got #{obj.class}"
      end

      def serialize_data(obj)
        obj.to_jwk(include_private: true).to_h
      end

      def deserialize_data(data)
        AtprotoAuth::DPoP::KeyManager.from_jwk(data)
      end
    end
  end
end
-----

lib/atproto_auth/serialization/session.rb:
# frozen_string_literal: true

module AtprotoAuth
  module Serialization
    # Handles serialization of Session objects
    class Session < Base
      def type_identifier
        "Session"
      end

      private

      def validate_object!(obj)
        return if obj.is_a?(AtprotoAuth::State::Session)

        raise ValidationError,
              "Expected Session object, got #{obj.class}"
      end

      def serialize_data(obj)
        {
          session_id: obj.session_id,
          state_token: obj.state_token,
          client_id: obj.client_id,
          scope: obj.scope,
          pkce_verifier: obj.pkce_verifier,
          pkce_challenge: obj.pkce_challenge,
          did: obj.did,
          tokens: serialize_token_set(obj.tokens),
          auth_server: serialize_auth_server(obj.auth_server)
        }
      end

      def deserialize_data(data)
        AtprotoAuth::State::Session.new(
          client_id: data["client_id"],
          scope: data["scope"],
          did: data["did"],
          auth_server: deserialize_auth_server(data["auth_server"])
        ).tap do |session|
          # Set readonly attributes
          session.instance_variable_set(:@session_id, data["session_id"])
          session.instance_variable_set(:@state_token, data["state_token"])
          session.instance_variable_set(:@pkce_verifier, data["pkce_verifier"])
          session.instance_variable_set(:@pkce_challenge, data["pkce_challenge"])

          # Set tokens if present
          session.tokens = deserialize_token_set(data["tokens"]) if data["tokens"]
        end
      end

      def serialize_token_set(tokens)
        return nil unless tokens

        TokenSet.new.serialize(tokens)
      end

      def deserialize_token_set(data)
        return nil unless data

        TokenSet.new.deserialize(data)
      end

      def serialize_auth_server(server)
        return nil unless server

        server.to_h
      end

      def deserialize_auth_server(data)
        return nil unless data

        AtprotoAuth::ServerMetadata::AuthorizationServer.new(data)
      end
    end
  end
end
-----

lib/atproto_auth/serialization/stored_nonce.rb:
# frozen_string_literal: true

module AtprotoAuth
  module Serialization
    # Handles serialization of StoredNonce objects
    class StoredNonce < Base
      def type_identifier
        "StoredNonce"
      end

      private

      def validate_object!(obj)
        return if obj.is_a?(AtprotoAuth::DPoP::NonceManager::StoredNonce)

        raise ValidationError,
              "Expected StoredNonce object, got #{obj.class}"
      end

      def serialize_data(obj)
        {
          value: obj.value,
          server_url: obj.server_url,
          timestamp: obj.timestamp
        }
      end

      def deserialize_data(data)
        AtprotoAuth::DPoP::NonceManager::StoredNonce.new(
          data["value"],
          data["server_url"],
          timestamp: Time.at(data["timestamp"])
        )
      end
    end
  end
end
-----

lib/atproto_auth/serialization/token_set.rb:
# frozen_string_literal: true

module AtprotoAuth
  module Serialization
    # Handles serialization of TokenSet objects
    class TokenSet < Base
      def type_identifier
        "TokenSet"
      end

      private

      def validate_object!(obj)
        return if obj.is_a?(AtprotoAuth::State::TokenSet)

        raise ValidationError,
              "Expected TokenSet object, got #{obj.class}"
      end

      def serialize_data(obj)
        {
          access_token: obj.access_token,
          refresh_token: obj.refresh_token,
          token_type: obj.token_type,
          expires_at: obj.expires_at.utc.iso8601,
          scope: obj.scope,
          sub: obj.sub
        }
      end

      def deserialize_data(data)
        AtprotoAuth::State::TokenSet.new(
          access_token: data["access_token"],
          refresh_token: data["refresh_token"],
          token_type: data["token_type"],
          expires_in: (Time.parse(data["expires_at"]) - Time.now).to_i,
          scope: data["scope"],
          sub: data["sub"]
        )
      end
    end
  end
end
-----

lib/atproto_auth/server_metadata/authorization_server.rb:
# frozen_string_literal: true

module AtprotoAuth
  module ServerMetadata
    # Handles fetching and validation of AT Protocol OAuth Authorization Server metadata.
    # An Authorization Server in atproto can be either a PDS instance or a separate "entryway" server
    # that handles authentication for multiple PDS instances.
    #
    # The Authorization Server metadata is fetched from the well-known endpoint
    # /.well-known/oauth-authorization-server and must conform to RFC 8414 plus additional
    # requirements specific to the AT Protocol OAuth profile.
    #
    # @example Fetching and validating Authorization Server metadata
    #   begin
    #     auth_server = AtprotoAuth::ServerMetadata::AuthorizationServer.from_issuer("https://auth.example.com")
    #     puts "Authorization endpoint: #{auth_server.authorization_endpoint}"
    #     puts "Supported scopes: #{auth_server.scopes_supported}"
    #   rescue AtprotoAuth::InvalidAuthorizationServer => e
    #     puts "Failed to validate authorization server: #{e.message}"
    #   end
    #
    # @see https://atproto.com/specs/oauth#authorization-servers Documentation of Authorization Server requirements
    class AuthorizationServer
      REQUIRED_FIELDS = %w[
        issuer
        authorization_endpoint
        token_endpoint
        response_types_supported
        grant_types_supported
        code_challenge_methods_supported
        token_endpoint_auth_methods_supported
        token_endpoint_auth_signing_alg_values_supported
        scopes_supported
        dpop_signing_alg_values_supported
        pushed_authorization_request_endpoint
      ].freeze

      attr_reader :issuer, :authorization_endpoint, :token_endpoint,
                  :pushed_authorization_request_endpoint, :response_types_supported,
                  :grant_types_supported, :code_challenge_methods_supported,
                  :token_endpoint_auth_methods_supported,
                  :token_endpoint_auth_signing_alg_values_supported,
                  :scopes_supported, :dpop_signing_alg_values_supported

      def initialize(metadata)
        validate_and_set_metadata!(metadata)
      end

      # Fetches and validates Authorization Server metadata from an issuer URL
      # @param issuer [String] Authorization Server issuer URL
      # @return [AuthorizationServer] new instance with fetched metadata
      # @raise [InvalidAuthorizationServer] if metadata is invalid
      def self.from_issuer(issuer)
        response = fetch_metadata(issuer)
        metadata = parse_metadata(response[:body])
        validate_issuer!(metadata["issuer"], issuer)
        new(metadata)
      end

      def to_h
        {
          issuer: issuer,
          authorization_endpoint: authorization_endpoint,
          token_endpoint: token_endpoint,
          pushed_authorization_request_endpoint: pushed_authorization_request_endpoint,
          response_types_supported: response_types_supported,
          grant_types_supported: grant_types_supported,
          code_challenge_methods_supported: code_challenge_methods_supported,
          token_endpoint_auth_methods_supported: token_endpoint_auth_methods_supported,
          token_endpoint_auth_signing_alg_values_supported: token_endpoint_auth_signing_alg_values_supported,
          scopes_supported: scopes_supported,
          dpop_signing_alg_values_supported: dpop_signing_alg_values_supported,
          authorization_response_iss_parameter_supported: true,
          require_pushed_authorization_requests: true,
          client_id_metadata_document_supported: true
        }
      end

      private

      def validate_and_set_metadata!(metadata)
        REQUIRED_FIELDS.each do |field|
          raise InvalidAuthorizationServer, "#{field} is required" unless metadata[field]
        end

        @issuer = validate_issuer!(metadata["issuer"])
        @authorization_endpoint = validate_https_url!(metadata["authorization_endpoint"])
        @token_endpoint = validate_https_url!(metadata["token_endpoint"])
        @pushed_authorization_request_endpoint = validate_https_url!(metadata["pushed_authorization_request_endpoint"])

        validate_response_types!(metadata["response_types_supported"])
        validate_grant_types!(metadata["grant_types_supported"])
        validate_code_challenge_methods!(metadata["code_challenge_methods_supported"])
        validate_token_endpoint_auth_methods!(metadata["token_endpoint_auth_methods_supported"])
        validate_token_endpoint_auth_signing_algs!(metadata["token_endpoint_auth_signing_alg_values_supported"])
        validate_dpop_signing_algs!(metadata["dpop_signing_alg_values_supported"])
        validate_scopes!(metadata["scopes_supported"])

        # Store validated values
        @response_types_supported = metadata["response_types_supported"]
        @grant_types_supported = metadata["grant_types_supported"]
        @code_challenge_methods_supported = metadata["code_challenge_methods_supported"]
        @token_endpoint_auth_methods_supported = metadata["token_endpoint_auth_methods_supported"]
        @token_endpoint_auth_signing_alg_values_supported = metadata["token_endpoint_auth_signing_alg_values_supported"]
        @scopes_supported = metadata["scopes_supported"]
        @dpop_signing_alg_values_supported = metadata["dpop_signing_alg_values_supported"]

        # Required boolean fields
        validate_boolean_field!(metadata, "authorization_response_iss_parameter_supported", true)
        validate_boolean_field!(metadata, "require_pushed_authorization_requests", true)
        validate_boolean_field!(metadata, "client_id_metadata_document_supported", true)
      end

      def validate_issuer!(issuer)
        is_valid = OriginUrl.new(issuer).valid?
        raise InvalidAuthorizationServer, "invalid issuer URL format" unless is_valid

        issuer
      end

      def validate_https_url!(url)
        uri = URI(url)
        raise InvalidAuthorizationServer, "URL must use HTTPS" unless uri.scheme == "https"

        url
      end

      def validate_response_types!(types)
        raise InvalidAuthorizationServer, "must support 'code' response type" unless types.include?("code")
      end

      def validate_grant_types!(types)
        required = %w[authorization_code refresh_token]
        missing = required - types
        raise InvalidAuthorizationServer, "missing grant types: #{missing.join(", ")}" if missing.any?
      end

      def validate_code_challenge_methods!(methods)
        raise InvalidAuthorizationServer, "must support S256 PKCE" unless methods.include?("S256")
      end

      def validate_token_endpoint_auth_methods!(methods)
        required = %w[private_key_jwt none]
        missing = required - methods
        raise InvalidAuthorizationServer, "missing auth methods: #{missing.join(", ")}" if missing.any?
      end

      def validate_token_endpoint_auth_signing_algs!(algs)
        raise InvalidAuthorizationServer, "must support ES256" unless algs.include?("ES256")
        raise InvalidAuthorizationServer, "must not allow 'none'" if algs.include?("none")
      end

      def validate_dpop_signing_algs!(algs)
        raise InvalidAuthorizationServer, "must support ES256 for DPoP" unless algs.include?("ES256")
      end

      def validate_scopes!(scopes)
        required = %w[atproto]
        missing = required - scopes
        raise InvalidAuthorizationServer, "missing scopes: #{missing.join(", ")}" if missing.any?
      end

      def validate_boolean_field!(metadata, field, required_value)
        actual = metadata[field]
        return if actual == required_value

        raise InvalidAuthorizationServer, "#{field} must be #{required_value}"
      end

      class << self
        private

        def fetch_metadata(issuer)
          metadata_url = URI.join(issuer, "/.well-known/oauth-authorization-server")
          AtprotoAuth.configuration.http_client.get(metadata_url.to_s)
        rescue HttpClient::HttpError => e
          raise InvalidAuthorizationServer, "Failed to fetch authorization server metadata: #{e.message}"
        end

        def parse_metadata(body)
          JSON.parse(body)
        rescue JSON::ParserError => e
          raise InvalidAuthorizationServer, "Invalid JSON in authorization server metadata: #{e.message}"
        end

        def validate_issuer!(metadata_issuer, request_issuer)
          return if metadata_issuer == request_issuer

          raise InvalidAuthorizationServer, "issuer mismatch: #{metadata_issuer} != #{request_issuer}"
        end
      end
    end
  end
end
-----

lib/atproto_auth/server_metadata/origin_url.rb:
# frozen_string_literal: true

module AtprotoAuth
  module ServerMetadata
    # The `OriginUrl` class provides validation logic for URLs that must conform
    # to the AT Protocol OAuth "simple origin URL" requirements. These requirements
    # are common between Resource and Authorization Servers and ensure that the URL
    # is valid and secure for use in the protocol. This class validates that the URL:
    # - Uses the HTTPS scheme.
    # - Points to the root path (either an empty path or "/").
    # - Does not include a query string or fragment.
    # - Does not include user or password credentials.
    # - May include a non-default port but disallows the default HTTPS port (443).
    #
    # This model centralizes the URL validation logic to promote reusability and
    # consistency between different server classes.
    class OriginUrl
      attr_reader :url, :uri

      def initialize(url)
        @url = url
        @uri = URI(url)
      end

      # Determines if a URL conforms to AT Protocol OAuth "simple origin URL" requirements
      # @return [Boolean] true if the URL is a valid origin URL
      def valid?
        https_scheme? &&
          root_path? &&
          !uri.query &&
          !uri.fragment &&
          !uri.userinfo &&
          (!explicit_port? || uri.port != 443)
      end

      private

      def https_scheme?
        uri.scheme == "https"
      end

      def root_path?
        uri.path.empty? || uri.path == "/"
      end

      def explicit_port?
        url.match?(/:\d+/)
      end
    end
  end
end
-----

lib/atproto_auth/server_metadata/resource_server.rb:
# frozen_string_literal: true

module AtprotoAuth
  module ServerMetadata
    # This class represents a Resource Server (PDS) and is responsible for
    # validating and managing its metadata. It ensures that the authorization
    # server URLs provided are valid and compliant with expected standards.
    # The class also includes functionality to fetch and parse metadata from a
    # remote URL, raising specific errors for invalid or malformed metadata.
    class ResourceServer
      attr_reader :authorization_servers

      def initialize(metadata)
        @authorization_servers = validate_authorization_servers!(metadata["authorization_servers"])
      end

      # Fetches and validates Resource Server metadata from a URL
      # @param url [String] PDS URL to fetch metadata from
      # @return [ResourceServer] new instance with fetched metadata
      # @raise [InvalidAuthorizationServer] if metadata is invalid
      def self.from_url(url)
        response = fetch_metadata(url)
        new(parse_metadata(response[:body]))
      end

      private

      def validate_authorization_servers!(servers)
        ensure_servers_exist(servers)
        ensure_exactly_one_server(servers)
        validate_server_url_format(servers.first)
        servers
      end

      def ensure_servers_exist(servers)
        return if servers.is_a?(Array)

        raise InvalidAuthorizationServer, "authorization_servers missing"
      end

      def ensure_exactly_one_server(servers)
        return if servers.size == 1

        raise InvalidAuthorizationServer, "must have exactly one authorization server"
      end

      def validate_server_url_format(server_url)
        return if OriginUrl.new(server_url).valid?

        raise InvalidAuthorizationServer, "invalid authorization server URL format for #{server_url}"
      end

      class << self
        private

        def fetch_metadata(url)
          metadata_url = URI.join(url, "/.well-known/oauth-protected-resource")
          AtprotoAuth.configuration.http_client.get(metadata_url.to_s)
        rescue HttpClient::HttpError => e
          raise InvalidAuthorizationServer, "Failed to fetch resource server metadata: #{e.message}"
        end

        def parse_metadata(body)
          JSON.parse(body)
        rescue JSON::ParserError => e
          raise InvalidAuthorizationServer, "Invalid JSON in resource server metadata: #{e.message}"
        end
      end
    end
  end
end
-----

lib/atproto_auth/server_metadata.rb:
# frozen_string_literal: true

module AtprotoAuth
  # Provides functionality for fetching and validating AT Protocol OAuth server metadata
  # from both Resource Servers (PDS instances) and Authorization Servers (PDS/entryway).
  #
  # The flow for resolving an account's authorization server is:
  # 1. Start with PDS URL
  # 2. Fetch Resource Server metadata from /.well-known/oauth-protected-resource
  # 3. Get Authorization Server URL from authorization_servers array
  # 4. Fetch Authorization Server metadata from /.well-known/oauth-authorization-server
  #
  # @example Resolving authorization server from PDS URL
  #   resource_server = AtprotoAuth::ServerMetadata::ResourceServer.from_url("https://pds.example.com")
  #   auth_server_url = resource_server.authorization_servers.first
  #   auth_server = AtprotoAuth::ServerMetadata::AuthorizationServer.from_issuer(auth_server_url)
  #
  # The module includes three main classes:
  # - {ResourceServer} - Handles PDS metadata validation and authorization server discovery
  # - {AuthorizationServer} - Handles authorization server metadata validation
  # - {OriginUrl} - Validates URLs conform to AT Protocol's "simple origin URL" requirements
  module ServerMetadata
  end
end
-----

lib/atproto_auth/state/session.rb:
# frozen_string_literal: true

require "securerandom"
require "time"
require "monitor"

module AtprotoAuth
  module State
    # Tracks state for an OAuth authorization flow session
    class Session
      include MonitorMixin

      attr_reader :session_id, :state_token, :client_id, :scope,
                  :pkce_verifier, :pkce_challenge, :auth_server,
                  :did, :tokens

      # Creates a new OAuth session
      # @param client_id [String] OAuth client ID
      # @param scope [String] Requested scope
      # @param auth_server [AuthorizationServer, nil] Optional pre-resolved auth server
      # @param did [String, nil] Optional pre-resolved DID
      def initialize(client_id:, scope:, auth_server: nil, did: nil)
        super() # Initialize MonitorMixin

        @session_id = SecureRandom.uuid
        @state_token = SecureRandom.urlsafe_base64(32)
        @client_id = client_id
        @scope = scope
        @auth_server = auth_server
        @did = did

        # Generate PKCE values
        @pkce_verifier = PKCE.generate_verifier
        @pkce_challenge = PKCE.generate_challenge(@pkce_verifier)

        @tokens = nil
      end

      # Updates the authorization server for this session
      # @param server [AuthorizationServer] The resolved auth server
      # @return [void]
      # @raise [SessionError] if session is already bound to different server
      def authorization_server=(server)
        synchronize do
          if @auth_server && @auth_server.issuer != server.issuer
            raise SessionError, "Session already bound to different authorization server"
          end

          @auth_server = server
        end
      end

      # Updates the user's DID for this session
      # @param did [String] The resolved DID
      # @return [void]
      # @raise [SessionError] if session already has different DID
      def did=(did)
        synchronize do
          raise SessionError, "Session already bound to different DID" if @did && @did != did

          @did = did
        end
      end

      # Updates tokens for this session
      # @param tokens [TokenSet] New token set
      # @return [void]
      # @raise [SessionError] if tokens don't match session DID
      def tokens=(tokens)
        synchronize do
          raise SessionError, "Token subject doesn't match session DID" if @did && tokens.sub != @did

          @tokens = tokens
          @did ||= tokens.sub
        end
      end

      # Whether this session has valid access tokens
      # @return [Boolean]
      def authorized?
        synchronize do
          !@tokens.nil? && !@tokens.expired?
        end
      end

      # Whether this session can refresh its tokens
      # @return [Boolean]
      def renewable?
        synchronize do
          !@tokens.nil? && @tokens.renewable?
        end
      end

      # Validates a state token against this session
      # @param state [String] State token to validate
      # @return [Boolean]
      def validate_state(state)
        return false unless state

        # Use secure comparison to prevent timing attacks
        secure_compare(@state_token, state)
      end

      private

      def secure_compare(str1, str2)
        return false unless str1.bytesize == str2.bytesize

        left = str1.unpack("C*")
        right = str2.unpack("C*")
        result = 0
        left.zip(right) { |x, y| result |= x ^ y }
        result.zero?
      end
    end
  end
end
-----

lib/atproto_auth/state/session_manager.rb:
# frozen_string_literal: true

module AtprotoAuth
  module State
    # Manages active OAuth sessions with secure persistent storage
    class SessionManager
      def initialize
        @serializer = Serialization::Session.new
      end

      # Creates and stores a new session
      # @param client_id [String] OAuth client ID
      # @param scope [String] Requested scope
      # @param auth_server [AuthorizationServer, nil] Optional pre-resolved auth server
      # @param did [String, nil] Optional pre-resolved DID
      # @return [Session] The created session
      def create_session(client_id:, scope:, auth_server: nil, did: nil)
        session = Session.new(
          client_id: client_id,
          scope: scope,
          auth_server: auth_server,
          did: did
        )

        # Store both session and state mapping atomically
        session_key = Storage::KeyBuilder.session_key(session.session_id)
        state_key = Storage::KeyBuilder.state_key(session.state_token)

        AtprotoAuth.storage.with_lock(session_key, ttl: 30) do
          serialized = @serializer.serialize(session)
          AtprotoAuth.storage.set(session_key, serialized)
          AtprotoAuth.storage.set(state_key, session.session_id)
        end

        session
      end

      # Updates an existing session
      # @return [Session] The session to update
      # @return [Session] The updated session
      def update_session(session)
        session_key = Storage::KeyBuilder.session_key(session.session_id)

        AtprotoAuth.storage.with_lock(session_key, ttl: 30) do
          serialized = @serializer.serialize(session)
          AtprotoAuth.storage.set(session_key, serialized)

          state_key = Storage::KeyBuilder.state_key(session.state_token)
          AtprotoAuth.storage.set(state_key, session.session_id)
        end

        session
      end

      # Retrieves a session by ID
      # @param session_id [String] Session ID to look up
      # @return [Session, nil] The session if found
      def get_session(session_id)
        session_key = Storage::KeyBuilder.session_key(session_id)

        begin
          serialized = AtprotoAuth.storage.get(session_key)
          return nil unless serialized
        rescue StandardError => e
          AtprotoAuth.configuration.logger.error("Failed to get session: #{e.message}")
          return nil
        end

        begin
          session = @serializer.deserialize(serialized)
          return nil if !session.renewable? && session.tokens&.expired?

          session
        rescue StandardError => e
          AtprotoAuth.configuration.logger.error("Failed to deserialize session: #{e.message}")
          nil
        end
      end

      # Finds a session by state token
      # @param state [String] State token to look up
      # @return [Session, nil] The session if found
      def get_session_by_state(state)
        return nil unless state

        state_key = Storage::KeyBuilder.state_key(state)

        begin
          session_id = AtprotoAuth.storage.get(state_key)
          return nil unless session_id
        rescue StandardError => e
          AtprotoAuth.configuration.logger.error("Failed to get session by state: #{e.message}")
          return nil
        end

        get_session(session_id)
      end

      # Removes a session
      # @param session_id [String] Session ID to remove
      # @return [void]
      def remove_session(session_id)
        session = get_session(session_id)
        return unless session

        session_key = Storage::KeyBuilder.session_key(session_id)
        state_key = Storage::KeyBuilder.state_key(session.state_token)

        AtprotoAuth.storage.with_lock(session_key, ttl: 30) do
          AtprotoAuth.storage.delete(session_key)
          AtprotoAuth.storage.delete(state_key)
        end
      end

      # Removes all expired sessions
      # @return [void]
      def cleanup_expired
        # No-op - expiry handled by storage TTL and retrieval validation
      end
    end
  end
end
-----

lib/atproto_auth/state/token_set.rb:
# frozen_string_literal: true

module AtprotoAuth
  module State
    # Represents a set of OAuth tokens and their associated metadata
    class TokenSet
      attr_reader :access_token, :refresh_token, :token_type,
                  :scope, :expires_at, :sub

      # Creates a new TokenSet from a token response
      # @param access_token [String] The access token
      # @param token_type [String] Token type (must be "DPoP")
      # @param expires_in [Integer] Token lifetime in seconds
      # @param refresh_token [String, nil] Optional refresh token
      # @param scope [String] Space-separated list of granted scopes
      # @param sub [String] DID of the authenticated user
      def initialize( # rubocop:disable Metrics/ParameterLists
        access_token:,
        token_type:,
        expires_in:,
        scope:,
        sub:,
        refresh_token: nil
      )
        validate_token_type!(token_type)
        validate_required!("access_token", access_token)
        validate_required!("scope", scope)
        validate_required!("sub", sub)
        validate_expires_in!(expires_in)

        @access_token = access_token
        @refresh_token = refresh_token
        @token_type = token_type
        @scope = scope
        @sub = sub
        @expires_at = Time.now + expires_in
      end

      # Whether this token set includes a refresh token
      # @return [Boolean]
      def renewable?
        !@refresh_token.nil?
      end

      # Whether the access token has expired
      # @return [Boolean]
      def expired?(buffer = 30)
        Time.now >= (@expires_at - buffer)
      end

      private

      def validate_token_type!(type)
        raise ArgumentError, "token_type must be DPoP" unless type == "DPoP"
      end

      def validate_required!(name, value)
        raise ArgumentError, "#{name} is required" if value.nil? || value.empty?
      end

      def validate_expires_in!(expires_in)
        return if expires_in.is_a?(Integer) && expires_in.positive?

        raise ArgumentError, "expires_in must be positive integer"
      end
    end
  end
end
-----

lib/atproto_auth/state.rb:
# frozen_string_literal: true

module AtprotoAuth
  # Manages OAuth state for AT Protocol authorization flows. This module provides thread-safe
  # storage and management of authorization session data, including tokens, PKCE values,
  # and identity information.
  #
  # The module consists of three main components:
  #
  # 1. {TokenSet} - Represents OAuth tokens (access and refresh) with their metadata,
  #    including expiration times, scope, and the authenticated user's DID.
  #
  # 2. {Session} - Tracks the complete state of an authorization flow, including:
  #    - PKCE verifier/challenge pairs
  #    - State tokens for request verification
  #    - Authorization server information
  #    - Current tokens and user identity (DID)
  #
  # 3. {SessionManager} - Provides thread-safe storage and retrieval of active sessions,
  #    with support for lookup by session ID or state token.
  #
  # @example Creating and managing a session
  #   manager = AtprotoAuth::State::SessionManager.new
  #
  #   # Create a new session
  #   session = manager.create_session(
  #     client_id: "https://myapp.com/client-metadata.json",
  #     scope: "atproto"
  #   )
  #
  #   # Update session with tokens
  #   tokens = TokenSet.new(
  #     access_token: "...",
  #     token_type: "DPoP",
  #     expires_in: 3600,
  #     scope: "atproto",
  #     sub: "did:plc:abcdef123"
  #   )
  #   session.tokens = tokens
  #
  #   # Lookup session later
  #   session = manager.get_session(session_id)
  #   if session.authorized?
  #     puts "Access token: #{session.tokens.access_token}"
  #   end
  #
  # All classes in this module are thread-safe and can be used in concurrent environments.
  # The module handles secure generation and validation of state tokens, and ensures
  # consistency of session data through synchronized access.
  module State
    # Error raised for session-related issues
    class SessionError < AtprotoAuth::Error; end
  end
end
-----

lib/atproto_auth/storage/interface.rb:
# frozen_string_literal: true

module AtprotoAuth
  module Storage
    # Base storage interface that all implementations must conform to
    class Interface
      # Store a value with optional TTL
      # @param key [String] Storage key
      # @param value [Object] Value to store
      # @param ttl [Integer, nil] Time-to-live in seconds
      # @return [Boolean] Success status
      # @raise [StorageError] if operation fails
      def set(key, value, ttl: nil)
        raise NotImplementedError
      end

      # Retrieve a value
      # @param key [String] Storage key
      # @return [Object, nil] Stored value or nil if not found
      # @raise [StorageError] if operation fails
      def get(key)
        raise NotImplementedError
      end

      # Delete a value
      # @param key [String] Storage key
      # @return [Boolean] Success status
      # @raise [StorageError] if operation fails
      def delete(key)
        raise NotImplementedError
      end

      # Check if key exists
      # @param key [String] Storage key
      # @return [Boolean] True if key exists
      # @raise [StorageError] if operation fails
      def exists?(key)
        raise NotImplementedError
      end

      # Get multiple values
      # @param keys [Array<String>] Storage keys
      # @return [Hash<String, Object>] Key-value pairs
      # @raise [StorageError] if operation fails
      def multi_get(keys)
        raise NotImplementedError
      end

      # Store multiple values
      # @param hash [Hash<String, Object>] Key-value pairs
      # @param ttl [Integer, nil] Time-to-live in seconds
      # @return [Boolean] Success status
      # @raise [StorageError] if operation fails
      def multi_set(hash, ttl: nil)
        raise NotImplementedError
      end

      # Acquire a lock
      # @param key [String] Lock key
      # @param ttl [Integer] Lock timeout in seconds
      # @return [Boolean] True if lock acquired
      # @raise [StorageError] if operation fails
      def acquire_lock(key, ttl:)
        raise NotImplementedError
      end

      # Release a lock
      # @param key [String] Lock key
      # @return [Boolean] Success status
      # @raise [StorageError] if operation fails
      def release_lock(key)
        raise NotImplementedError
      end

      # Execute block with lock
      # @param key [String] Lock key
      # @param ttl [Integer] Lock timeout in seconds
      # @yield Block to execute with lock
      # @return [Object] Block result
      # @raise [StorageError] if operation fails
      def with_lock(key, ttl: 30)
        raise NotImplementedError
      end

      protected

      # Validate key format
      # @param key [String] Key to validate
      # @raise [StorageError] if key is invalid
      def validate_key!(key)
        raise StorageError, "Key cannot be nil" if key.nil?
        raise StorageError, "Key must be a string" unless key.is_a?(String)
        raise StorageError, "Key cannot be empty" if key.empty?
        raise StorageError, "Invalid key format" unless key.start_with?("atproto:")
      end

      # Validate TTL value
      # @param ttl [Integer, nil] TTL to validate
      # @raise [StorageError] if TTL is invalid
      def validate_ttl!(ttl)
        return if ttl.nil?
        raise StorageError, "TTL must be a positive integer" unless ttl.is_a?(Integer) && ttl.positive?
      end
    end

    # Base error class for storage operations
    class StorageError < AtprotoAuth::Error; end

    # Error for lock-related operations
    class LockError < StorageError; end
  end
end
-----

lib/atproto_auth/storage/key_builder.rb:
# frozen_string_literal: true

module AtprotoAuth
  module Storage
    # Utility for building storage keys with correct format
    class KeyBuilder
      NAMESPACE_SEPARATOR = ":"
      NAMESPACE_PREFIX = "atproto"

      class << self
        def session_key(id)
          build_key("session", id)
        end

        def state_key(token)
          build_key("state", token)
        end

        def nonce_key(server_url)
          build_key("nonce", server_url)
        end

        def dpop_key(client_id)
          build_key("dpop", client_id)
        end

        def lock_key(namespace, id)
          build_key("lock", namespace, id)
        end

        private

        def build_key(*parts)
          [NAMESPACE_PREFIX, *parts].join(NAMESPACE_SEPARATOR)
        end
      end
    end
  end
end
-----

lib/atproto_auth/storage/memory.rb:
# frozen_string_literal: true

require "monitor"

module AtprotoAuth
  module Storage
    # Thread-safe in-memory storage implementation
    class Memory < Interface
      def initialize
        super
        @data = {}
        @locks = {}
        @expirations = {}
        @monitor = Monitor.new
        @cleanup_interval = 60 # 1 minute
        start_cleanup_thread
      end

      def set(key, value, ttl: nil)
        validate_key!(key)
        validate_ttl!(ttl)

        @monitor.synchronize do
          @data[key] = value
          set_expiration(key, ttl) if ttl
          true
        end
      end

      def get(key)
        validate_key!(key)

        @monitor.synchronize do
          return nil if expired?(key)

          @data[key]
        end
      end

      def delete(key)
        validate_key!(key)

        @monitor.synchronize do
          @data.delete(key)
          @expirations.delete(key)
          true
        end
      end

      def exists?(key)
        validate_key!(key)

        @monitor.synchronize do
          return false unless @data.key?(key)
          return false if expired?(key)

          true
        end
      end

      def multi_get(keys)
        keys.each { |key| validate_key!(key) }

        @monitor.synchronize do
          result = {}
          keys.each do |key|
            result[key] = @data[key] if @data.key?(key) && !expired?(key)
          end
          result
        end
      end

      def multi_set(hash, ttl: nil)
        hash.each_key { |key| validate_key!(key) }
        validate_ttl!(ttl)

        @monitor.synchronize do
          hash.each do |key, value|
            @data[key] = value
            set_expiration(key, ttl) if ttl
          end
          true
        end
      end

      def acquire_lock(key, ttl:)
        validate_key!(key)
        validate_ttl!(ttl)
        lock_key = "lock:#{key}"

        @monitor.synchronize do
          return false if @locks[lock_key] && !lock_expired?(lock_key)

          @locks[lock_key] = Time.now.to_i + ttl
          true
        end
      end

      def release_lock(key)
        validate_key!(key)
        lock_key = "lock:#{key}"

        @monitor.synchronize do
          @locks.delete(lock_key)
          true
        end
      end

      def with_lock(key, ttl: 30)
        raise ArgumentError, "Block required" unless block_given?

        acquired = acquire_lock(key, ttl: ttl)
        raise LockError, "Failed to acquire lock" unless acquired

        begin
          yield
        ensure
          release_lock(key)
        end
      end

      def clear
        @monitor.synchronize do
          @data.clear
          @expirations.clear
          @locks.clear
        end
      end

      private

      def expired?(key)
        return false unless @expirations.key?(key)

        expiry = @expirations[key]
        if Time.now.to_i >= expiry
          @data.delete(key)
          @expirations.delete(key)
          true
        else
          false
        end
      end

      def lock_expired?(lock_key)
        expiry = @locks[lock_key]
        return false unless expiry

        if Time.now.to_i >= expiry
          @locks.delete(lock_key)
          true
        else
          false
        end
      end

      def set_expiration(key, ttl)
        @expirations[key] = Time.now.to_i + ttl
      end

      def cleanup_expired
        @monitor.synchronize do
          now = Time.now.to_i

          # Cleanup expired data
          @expirations.each do |key, expiry|
            if now >= expiry
              @data.delete(key)
              @expirations.delete(key)
            end
          end

          # Cleanup expired locks
          @locks.delete_if { |_, expiry| now >= expiry }
        end
      end

      def start_cleanup_thread
        Thread.new do
          loop do
            sleep @cleanup_interval
            cleanup_expired
          rescue StandardError => e
            # Log error but keep thread running
            AtprotoAuth.configuration.logger.error "Storage cleanup error: #{e.message}"
          end
        end
      end
    end
  end
end
-----

lib/atproto_auth/storage/redis.rb:
# frozen_string_literal: true

require "redis"

module AtprotoAuth
  module Storage
    # Redis storage implementation
    class Redis < Interface
      # Error raised for Redis-specific issues
      class RedisError < StorageError; end

      def initialize(redis_client: nil)
        super()
        @redis_client = redis_client || ::Redis.new
      end

      def set(key, value, ttl: nil)
        validate_key!(key)
        validate_ttl!(ttl) if ttl

        @redis_client.set(key, value, ex: ttl)
        true
      rescue ::Redis::BaseError => e
        raise RedisError, "Failed to set value: #{e.message}"
      end

      def get(key)
        validate_key!(key)

        value = @redis_client.get(key)
        value.nil? || value == "" ? nil : value
      rescue ::Redis::BaseError => e
        raise RedisError, "Failed to get value: #{e.message}"
      end

      def delete(key)
        validate_key!(key)

        @redis_client.del(key).positive?
      rescue ::Redis::BaseError => e
        raise RedisError, "Failed to delete value: #{e.message}"
      end

      def exists?(key)
        validate_key!(key)

        @redis_client.exists?(key)
      rescue ::Redis::BaseError => e
        raise RedisError, "Failed to check existence: #{e.message}"
      end

      def multi_get(keys)
        keys.each { |key| validate_key!(key) }

        values = @redis_client.mget(keys)
        result = {}

        # Only include non-nil values in result hash
        keys.zip(values).each do |key, value|
          next if value.nil? || value == ""

          result[key] = value
        end

        result
      rescue ::Redis::BaseError => e
        raise RedisError, "Failed to get multiple values: #{e.message}"
      end

      def multi_set(hash, ttl: nil)
        hash.each_key { |key| validate_key!(key) }
        validate_ttl!(ttl) if ttl

        @redis_client.multi do |tx|
          hash.each do |key, value|
            tx.set(key, value, ex: ttl)
          end
        end
        true
      rescue ::Redis::BaseError => e
        raise RedisError, "Failed to set multiple values: #{e.message}"
      end

      def acquire_lock(key, ttl:)
        validate_key!(key)
        validate_ttl!(ttl)

        lock_key = "atproto:locks:#{key}"
        @redis_client.set(lock_key, Time.now.to_i, nx: true, ex: ttl)
      rescue ::Redis::BaseError => e
        raise RedisError, "Failed to acquire lock: #{e.message}"
      end

      def release_lock(key)
        validate_key!(key)

        lock_key = "atproto:locks:#{key}"
        @redis_client.del(lock_key).positive?
      rescue ::Redis::BaseError => e
        raise RedisError, "Failed to release lock: #{e.message}"
      end

      def with_lock(key, ttl: 30)
        raise ArgumentError, "Block required" unless block_given?

        acquired = acquire_lock(key, ttl: ttl)
        raise LockError, "Failed to acquire lock" unless acquired

        begin
          yield
        ensure
          release_lock(key)
        end
      rescue ::Redis::BaseError => e
        raise RedisError, "Lock operation failed: #{e.message}"
      end
    end
  end
end
-----

lib/atproto_auth/token/refresh.rb:
# frozen_string_literal: true

module AtprotoAuth
  module Token
    # Base error class for token-related errors
    class Error < AtprotoAuth::Error
      attr_reader :token_type, :error_code, :retry_possible

      def initialize(message, token_type:, error_code:, retry_possible: false)
        @token_type = token_type
        @error_code = error_code
        @retry_possible = retry_possible
        super(message)
      end
    end

    # Specific token error types
    class ExpiredTokenError < Error
      def initialize(token_type:)
        super(
          "Token has expired",
          token_type: token_type,
          error_code: "token_expired",
          retry_possible: true
        )
      end
    end

    # Raised when a token is structurally valid but has been invalidated or revoked
    class InvalidTokenError < Error
      def initialize(token_type:)
        super(
          "Token is invalid",
          token_type: token_type,
          error_code: "token_invalid",
          retry_possible: false
        )
      end
    end

    # Raised during token refresh operations, includes retry information and server responses
    class RefreshError < Error
      def initialize(message, retry_possible: true)
        super(
          message,
          token_type: "refresh",
          error_code: "refresh_failed",
          retry_possible: retry_possible
        )
      end
    end

    # Handles token refresh operations with retry logic
    class Refresh
      include MonitorMixin

      # Maximum number of refresh attempts
      MAX_RETRIES = 3
      # Base delay between retries in seconds
      BASE_DELAY = 1
      # Maximum delay between retries in seconds
      MAX_DELAY = 8

      attr_reader :session, :dpop_client, :auth_server, :client_metadata

      def initialize(session:, dpop_client:, auth_server:, client_metadata:)
        super() # Initialize MonitorMixin
        @session = session
        @dpop_client = dpop_client
        @auth_server = auth_server
        @attempt_count = 0
        @client_metadata = client_metadata
      end

      # Performs token refresh with retry logic
      # @return [TokenSet] New token set
      # @raise [RefreshError] if refresh fails
      def perform!
        synchronize do
          raise RefreshError.new("No refresh token available", retry_possible: false) unless session.renewable?
          raise RefreshError.new("No access token to refresh", retry_possible: false) if session.tokens.nil?

          with_retries do
            request_token_refresh
          end
        end
      end

      private

      def with_retries
        @attempt_count = 0
        last_error = nil

        while @attempt_count < MAX_RETRIES
          begin
            return yield
          rescue StandardError => e
            last_error = e
            @attempt_count += 1

            # Don't retry if error indicates retry not possible
            raise e if e.respond_to?(:retry_possible) && !e.retry_possible

            sleep calculate_delay if @attempt_count < MAX_RETRIES
          end
        end

        # Reached max retries
        raise RefreshError.new(
          "Token refresh failed after #{MAX_RETRIES} attempts: #{last_error.message}",
          retry_possible: false
        )
      end

      def calculate_delay
        # Exponential backoff with jitter
        delay = [BASE_DELAY * (2**(@attempt_count - 1)), MAX_DELAY].min
        delay + (rand * 0.5 * delay) # Add up to 50% jitter
      end

      def request_token_refresh
        # Generate DPoP proof for token request
        proof = dpop_client.generate_proof(
          http_method: "POST",
          http_uri: auth_server.token_endpoint
        )

        # Build refresh request
        body = {
          grant_type: "refresh_token",
          refresh_token: session.tokens.refresh_token,
          scope: session.scope
        }

        # Add client authentication if available
        add_client_authentication!(body) if client_metadata.confidential?

        # Make request
        response = AtprotoAuth.configuration.http_client.post(
          auth_server.token_endpoint,
          body: body,
          headers: {
            "Content-Type" => "application/x-www-form-urlencoded",
            "DPoP" => proof
          }
        )

        handle_refresh_response(response)
      end

      def add_client_authentication!(body)
        return unless session.client_metadata.jwks && !session.client_metadata.jwks["keys"].empty?

        signing_key = JOSE::JWK.from_map(session.client_metadata.jwks["keys"].first)
        client_assertion = PAR::ClientAssertion.new(
          client_id: session.client_metadata.client_id,
          signing_key: signing_key
        )

        body.merge!(
          client_assertion_type: PAR::CLIENT_ASSERTION_TYPE,
          client_assertion: client_assertion.generate_jwt(
            audience: auth_server.issuer
          )
        )
      end

      def handle_refresh_response(response)
        case response[:status]
        when 200
          process_successful_response(response)
        when 400
          handle_400_response(response)
        when 401
          raise RefreshError.new("Refresh token is invalid", retry_possible: false)
        when 429
          handle_rate_limit_response(response)
        else
          raise RefreshError, "Unexpected response: #{response[:status]}"
        end
      end

      def process_successful_response(response)
        data = JSON.parse(response[:body])
        validate_refresh_response!(data)

        AtprotoAuth::State::TokenSet.new(
          access_token: data["access_token"],
          token_type: data["token_type"],
          expires_in: data["expires_in"],
          refresh_token: data["refresh_token"],
          scope: data["scope"],
          sub: data["sub"]
        )
      rescue JSON::ParserError => e
        raise RefreshError, "Invalid response format: #{e.message}"
      end

      def handle_400_response(response)
        error_data = JSON.parse(response[:body])
        error_description = error_data["error_description"] || error_data["error"]

        # Handle DPoP nonce requirement
        if error_data["error"] == "use_dpop_nonce"
          dpop_client.process_response(response[:headers], auth_server.issuer)
          raise RefreshError, "Retry with DPoP nonce"
        end

        raise RefreshError.new(
          "Refresh request failed: #{error_description}",
          retry_possible: false
        )
      rescue JSON::ParserError
        raise RefreshError, "Invalid error response format"
      end

      def handle_rate_limit_response(response)
        # Extract retry-after if available
        retry_after = response[:headers]["Retry-After"]&.to_i || calculate_delay
        raise RefreshError, "Rate limited - retry after #{retry_after} seconds"
      end

      def validate_refresh_response!(data)
        # Required fields
        %w[access_token token_type expires_in scope sub].each do |field|
          raise RefreshError.new("Missing #{field} in response", retry_possible: false) unless data[field]
        end

        # Token type must be DPoP
        unless data["token_type"] == "DPoP"
          raise RefreshError.new("Invalid token_type: #{data["token_type"]}", retry_possible: false)
        end

        # Scope must include original scopes
        original_scopes = session.scope.split
        response_scopes = data["scope"].split
        unless (original_scopes - response_scopes).empty?
          raise RefreshError.new("Invalid scope in response", retry_possible: false)
        end

        # Subject must match
        return if data["sub"] == session.tokens.sub

        raise RefreshError.new("Subject mismatch in response", retry_possible: false)
      end
    end
  end
end
-----

lib/atproto_auth/version.rb:
# frozen_string_literal: true

module AtprotoAuth
  VERSION = "0.0.1"
end
-----

lib/atproto_auth.rb:
# frozen_string_literal: true

require "jose"
require "jwt"

require "atproto_auth/version"

require "atproto_auth/errors"
require "atproto_auth/configuration"
require "atproto_auth/encryption"
require "atproto_auth/client_metadata"
require "atproto_auth/http_client"
require "atproto_auth/pkce"

require "atproto_auth/storage/interface"
require "atproto_auth/storage/key_builder"
require "atproto_auth/storage/memory"
require "atproto_auth/storage/redis"

require "atproto_auth/server_metadata"
require "atproto_auth/server_metadata/origin_url"
require "atproto_auth/server_metadata/authorization_server"
require "atproto_auth/server_metadata/resource_server"

require "atproto_auth/dpop/key_manager"
require "atproto_auth/dpop/proof_generator"
require "atproto_auth/dpop/nonce_manager"
require "atproto_auth/dpop/client"

require "atproto_auth/state"
require "atproto_auth/state/token_set"
require "atproto_auth/state/session"
require "atproto_auth/state/session_manager"

require "atproto_auth/identity"
require "atproto_auth/identity/document"
require "atproto_auth/identity/resolver"

require "atproto_auth/par"
require "atproto_auth/par/client_assertion"
require "atproto_auth/par/request"
require "atproto_auth/par/response"
require "atproto_auth/par/client"

require "atproto_auth/serialization/base"
require "atproto_auth/serialization/dpop_key"
require "atproto_auth/serialization/session"
require "atproto_auth/serialization/stored_nonce"
require "atproto_auth/serialization/token_set"

require "atproto_auth/token/refresh"

require "atproto_auth/client"

# AtprotoAuth is a Ruby library implementing the AT Protocol OAuth specification.
# It provides functionality for both client and server-side implementations of
# the AT Protocol OAuth flow, including support for DPoP, PAR, and dynamic client registration.
module AtprotoAuth
  class << self
    attr_writer :configuration

    def configuration
      @configuration ||= Configuration.new
    end

    def configure
      yield(configuration)
      configuration.validate!
      configuration
    end

    # Gets the configured storage backend
    # @return [Storage::Interface] The configured storage implementation
    def storage
      configuration.storage
    end

    # Resets the configuration to defaults
    # Primarily used in testing
    def reset_configuration!
      @configuration = Configuration.new
    end
  end
end
-----

sig/atproto_auth/client_metadata.rbs:
module AtprotoAuth
  # Handles and validates AT Protocol OAuth client metadata.
  class ClientMetadata
    @client_id: String

    @grant_types: Array[String]

    @response_types: Array[String]

    @redirect_uris: Array[String]

    @scope: String

    @client_name: String?

    @application_type: String

    @client_uri: String?

    @logo_uri: String?

    @tos_uri: String?

    @policy_uri: String?

    @token_endpoint_auth_method: String?

    @jwks: Hash[String, untyped]?

    @jwks_uri: String?

    attr_reader client_id: String
    attr_reader grant_types: Array[String]
    attr_reader response_types: Array[String]
    attr_reader redirect_uris: Array[String]
    attr_reader scope: String
    attr_reader client_name: String?
    attr_reader client_uri: String?
    attr_reader logo_uri: String?
    attr_reader tos_uri: String?
    attr_reader policy_uri: String?
    attr_reader token_endpoint_auth_method: String?
    attr_reader jwks: Hash[String, untyped]?
    attr_reader jwks_uri: String?
    attr_reader application_type: String

    def initialize: (Hash[String, untyped] metadata) -> void

    def self.from_url: (String url) -> ClientMetadata

    def confidential?: () -> bool

    private

    def validate_and_set_metadata!: (Hash[String, untyped] metadata) -> void

    def validate_client_id!: (String client_id) -> String

    def validate_grant_types!: (Array[String] grant_types) -> Array[String]

    def validate_response_types!: (Array[String] response_types) -> Array[String]

    def validate_redirect_uris!: (Array[String] uris) -> Array[String]

    def validate_redirect_uri!: (URI uri) -> void

    def validate_redirect_uri_origin!: (URI uri) -> void

    def validate_native_redirect_uri!: (URI uri) -> void

    def validate_custom_scheme!: (URI uri) -> void

    def validate_scope!: (String scope) -> String

    def validate_offline_access_scope!: (Array[String] scope_values) -> void

    def validate_application_type: (String? type) -> String

    def validate_client_uri: (String? uri) -> String?

    def validate_https_uri: (String? uri) -> String?

    def validate_auth_methods!: (Hash[String, untyped] metadata) -> void

    def validate_dpop!: (Hash[String, untyped] metadata) -> void

    def self.validate_url!: (String url) -> void

    def self.fetch_metadata: (String url) -> Hash[Symbol, untyped]

    def self.parse_metadata: (String body) -> Hash[String, untyped]

    def self.validate_client_id!: (String metadata_client_id, String url) -> void
  end
end
-----

sig/atproto_auth/dpop/client.rbs:
module AtprotoAuth
  module DPoP
    class Client
      @key_manager: untyped

      @nonce_manager: untyped

      @proof_generator: untyped

      class Error < AtprotoAuth::Error
      end

      attr_reader key_manager: untyped

      attr_reader proof_generator: untyped

      attr_reader nonce_manager: untyped

      def initialize: (?key_manager: untyped?, ?nonce_ttl: untyped?) -> void

      def generate_proof: (http_method: untyped, http_uri: untyped, ?access_token: untyped?) -> untyped

      def process_response: (untyped response_headers, untyped server_url) -> untyped

      def request_headers: (untyped proof) -> { "DPoP" => untyped }

      def public_key: () -> untyped

      def export_key: (?include_private: bool) -> untyped

      private

      def extract_nonce: (untyped headers) -> untyped

      def origin_for_uri: (untyped uri) -> untyped
    end
  end
end
-----

sig/atproto_auth/dpop/key_manager.rbs:
module AtprotoAuth
  module DPoP
    class KeyManager
      @keypair: JOSE::JWK

      class KeyError < AtprotoAuth::Error
      end

      CURVE: String
      ALGORITHM: String

      attr_reader keypair: JOSE::JWK

      def initialize: (?JOSE::JWK keypair) -> void

      def generate_keypair: () -> JOSE::JWK

      def public_jwk: () -> Hash[String, untyped]

      def sign: (String data) -> String

      def verify: (String signature, String data) -> bool

      def to_jwk: (?include_private: bool) -> Hash[String, untyped]

      def self.from_jwk: (Hash[String, untyped] jwk) -> AtprotoAuth::DPoP::KeyManager

      private

      def validate_keypair!: () -> void
    end
  end
end
-----

sig/atproto_auth/dpop/nonce_manager.rbs:
module AtprotoAuth
  module DPoP
    class NonceManager
      @ttl: Integer
      @nonces: Hash[String, AtprotoAuth::DPoP::NonceManager::StoredNonce]
      @monitor: Monitor

      class NonceError < AtprotoAuth::Error
      end

      class StoredNonce
        @value: String
        @server_url: String
        @timestamp: Integer

        attr_reader value: String
        attr_reader timestamp: Integer
        attr_reader server_url: String

        def initialize: (String value, String server_url) -> void

        def expired?: (?Integer ttl) -> bool
      end

      DEFAULT_TTL: Integer

      def initialize: (?ttl: Integer) -> void

      def update: (nonce: String, server_url: String) -> void

      def get: (String server_url) -> (nil | String)

      def clear: (String server_url) -> void

      def clear_all: () -> void

      def server_urls: () -> Array[String]

      def valid_nonce?: (String server_url) -> bool

      private

      def validate_inputs!: (String nonce, String server_url) -> void

      def validate_server_url!: (String server_url) -> void
    end
  end
end
-----

sig/atproto_auth/dpop/proof_generator.rbs:
module AtprotoAuth
  module DPoP
    class ProofGenerator
      @key_manager: AtprotoAuth::DPoP::KeyManager

      class ProofError < AtprotoAuth::Error
      end

      attr_reader key_manager: AtprotoAuth::DPoP::KeyManager

      def initialize: (AtprotoAuth::DPoP::KeyManager key_manager) -> void

      def generate: (
          http_method: String,
          http_uri: String,
          ?nonce: String?,
          ?access_token: String?,
          ?ath: bool?
        ) -> String

      private

      def validate_inputs!: (String http_method, String http_uri) -> void

      def build_header: () -> { typ: "dpop+jwt", alg: "ES256", jwk: Hash[String, untyped] }

      def build_payload: (
          http_method: String,
          http_uri: String,
          nonce: String?,
          access_token: String?,
          include_ath: bool
        ) -> Hash[Symbol, untyped]

      def normalize_uri: (String uri) -> String

      def generate_access_token_hash: (String access_token) -> String

      def encode_jwt_segments: (Hash[Symbol, untyped] header, Hash[Symbol, untyped] payload) -> String
    end
  end
end
-----

sig/atproto_auth/http_client.rbs:
module AtprotoAuth
  class HttpClient
    @timeout: Integer

    @verify_ssl: bool

    FORBIDDEN_IP_RANGES: ::Array[IPAddr]

    ALLOWED_SCHEMES: ::Array[String]

    DEFAULT_TIMEOUT: Integer

    MAX_REDIRECTS: Integer

    MAX_RESPONSE_SIZE: Integer

    class SSRFError < Error
    end

    class HttpError < Error
      @response: ::Net::HTTPResponse?

      attr_reader response: ::Net::HTTPResponse?

      def initialize: (String message, ::Net::HTTPResponse? response) -> void
    end

    def initialize: (?timeout: Integer, ?verify_ssl: bool) -> void

    def get: (String url, ?::Hash[String, String] headers) -> { status: Integer, headers: ::Hash[String, String], body: String }

    private

    def validate_uri!: (String url) -> URI

    def validate_ip!: (URI uri) -> nil

    def resolve_ip: (String hostname) -> IPAddr

    def forbidden_ip?: (IPAddr ip) -> bool

    def make_request: (URI uri, ?::Hash[String, String] headers) -> ::Net::HTTPResponse

    def configure_http_client!: (::Net::HTTP http) -> void

    def add_security_headers!: (::Net::HTTP::Get request, ::Hash[String, String] headers) -> void

    def handle_redirect: (URI original_uri, ::Net::HTTPResponse response, ::Hash[String, String] headers, ?::Integer redirect_count) -> ::Net::HTTPResponse

    def validate_response!: (::Net::HTTPResponse response) -> void

    def check_success_status!: (::Net::HTTPResponse response) -> nil

    def check_content_length!: (::Net::HTTPResponse response) -> nil

    def check_content_type!: (::Net::HTTPResponse response) -> nil
  end
end
-----

sig/atproto_auth/identity/document.rbs:
module AtprotoAuth
  module Identity
    class Document
      @did: String
      @rotation_keys: Array[String]
      @also_known_as: Array[String]
      @services: Array[Hash[String, untyped]]
      @pds: String

      attr_reader did: String
      attr_reader rotation_keys: Array[String]
      attr_reader also_known_as: Array[String]
      attr_reader services: Array[Hash[String, untyped]]
      attr_reader pds: String

      def initialize: (Hash[String, untyped] data) -> void

      def has_handle?: (String handle) -> bool

      private

      def validate_document!: (Hash[String, untyped] data) -> void

      def validate_did!: (String did) -> void

      def validate_services!: (Array[Hash[String, untyped]]? services) -> void

      def extract_pds!: (Hash[String, untyped] data) -> String
    end
  end
end
-----

sig/atproto_auth/identity/resolver.rbs:
module AtprotoAuth
  module Identity
    class Resolver
      @plc_directory: String

      PLC_DIRECTORY_URL: String
      DID_PLC_PREFIX: String
      HANDLE_REGEX: ::Regexp

      def initialize: (?plc_directory: String?) -> void

      def resolve_handle: (String handle) -> Hash[Symbol, untyped]

      def get_did_info: (String did) -> Hash[Symbol, untyped]

      def verify_pds_binding: (String did, String pds_url) -> bool

      def verify_issuer_binding: (String did, String issuer) -> bool

      def verify_handle_binding: (String handle, String did) -> bool

      private

      def validate_handle!: (String handle) -> void

      def validate_did!: (String did) -> void

      def normalize_handle: (String handle) -> String

      def resolve_handle_dns: (String _handle) -> nil

      def resolve_handle_http: (String handle) -> Hash[Symbol, untyped]

      def fetch_did_document: (String did) -> Hash[String, untyped]

      def validate_pds_url!: (String url) -> void

      def normalize_url: (String url) -> String
    end
  end
end
-----

sig/atproto_auth/par/client.rbs:
module AtprotoAuth
  module PAR
    class Client
      @endpoint: String

      attr_reader endpoint: String

      def initialize: (endpoint: String) -> void

      def submit: (Request request) -> Response

      def authorization_url: (
          authorize_endpoint: String,
          request_uri: String,
          client_id: String
        ) -> String

      private

      def validate_endpoint!: () -> void

      def build_headers: (Request request) -> Hash[String, String]

      def make_request: (Request request, Hash[String, String] headers) -> Hash[Symbol, untyped]

      def process_response: (Hash[Symbol, untyped] response) -> Response

      def encode_params: (Hash[String, String]) -> String
    end
  end
end
-----

sig/atproto_auth/par/request.rbs:
module AtprotoAuth
  module PAR
    class Request
      @response_type: String
      @client_id: String
      @redirect_uri: String
      @code_challenge: String
      @code_challenge_method: String
      @state: String
      @scope: String
      @login_hint: String?
      @nonce: String?
      @dpop_proof: String?
      @client_assertion_type: String?
      @client_assertion: String?

      class Configuration
        attr_accessor client_id: String
        attr_accessor redirect_uri: String
        attr_accessor code_challenge: String
        attr_accessor code_challenge_method: String
        attr_accessor state: String
        attr_accessor scope: String
        attr_accessor login_hint: String?
        attr_accessor nonce: String?
        attr_accessor dpop_proof: String?
        attr_accessor client_assertion_type: String?
        attr_accessor client_assertion: String?
      end

      attr_reader response_type: String
      attr_reader client_id: String
      attr_reader code_challenge: String
      attr_reader code_challenge_method: String
      attr_reader state: String
      attr_reader redirect_uri: String
      attr_reader scope: String
      attr_reader login_hint: String?
      attr_reader nonce: String?
      attr_reader dpop_proof: String?
      attr_reader client_assertion_type: String?
      attr_reader client_assertion: String?

      def self.build: () { (Configuration) -> void } -> Request

      def initialize: (Configuration config) -> void

      def to_form: () -> String

      private

      def build_params: () -> Hash[String, String]

      def add_optional_params: (Hash[String, String] params) -> void

      def add_client_auth_params: (Hash[String, String] params) -> void

      def validate!: () -> void

      def validate_required_params!: () -> void

      def validate_response_type!: () -> void

      def validate_code_challenge_method!: () -> void

      def validate_scope!: () -> void

      def validate_client_auth!: () -> void

      def encode_params: (Hash[String, String]) -> String
    end
  end
end
-----

sig/atproto_auth/par/response.rbs:
module AtprotoAuth
  module PAR
    class Response
      @request_uri: String
      @expires_in: Integer

      attr_reader request_uri: String
      attr_reader expires_in: Integer

      def initialize: (request_uri: String, expires_in: Integer) -> void

      private

      def validate!: () -> void
    end
  end
end
-----

sig/atproto_auth/pkce.rbs:
module AtprotoAuth
  module PKCE
    class Error < AtprotoAuth::Error
    end

    MIN_VERIFIER_LENGTH: Integer
    MAX_VERIFIER_LENGTH: Integer
    ALLOWED_VERIFIER_CHARS: ::Regexp

    def self.generate_verifier: (?Integer length) -> String

    def self.generate_challenge: (String verifier) -> String

    def self.verify: (String challenge, String verifier) -> bool

    private

    def self.validate_verifier_length!: (Integer length) -> void

    def self.validate_verifier!: (String verifier) -> void

    def self.secure_compare: (String str1, String str2) -> bool
  end
end
-----

sig/atproto_auth/server_metadata/authorization_server.rbs:
module AtprotoAuth
  module ServerMetadata
    class AuthorizationServer
      @issuer: String
      @authorization_endpoint: String
      @token_endpoint: String
      @pushed_authorization_request_endpoint: String
      @response_types_supported: Array[String]
      @grant_types_supported: Array[String]
      @code_challenge_methods_supported: Array[String]
      @token_endpoint_auth_methods_supported: Array[String]
      @token_endpoint_auth_signing_alg_values_supported: Array[String]
      @scopes_supported: Array[String]
      @dpop_signing_alg_values_supported: Array[String]

      REQUIRED_FIELDS: ::Array["issuer" | "authorization_endpoint" | "token_endpoint" | "response_types_supported" | "grant_types_supported" | "code_challenge_methods_supported" | "token_endpoint_auth_methods_supported" | "token_endpoint_auth_signing_alg_values_supported" | "scopes_supported" | "dpop_signing_alg_values_supported" | "pushed_authorization_request_endpoint"]

      attr_reader issuer: String
      attr_reader authorization_endpoint: String
      attr_reader token_endpoint: String
      attr_reader pushed_authorization_request_endpoint: String
      attr_reader response_types_supported: Array[String]
      attr_reader grant_types_supported: Array[String]
      attr_reader code_challenge_methods_supported: Array[String]
      attr_reader token_endpoint_auth_methods_supported: Array[String]
      attr_reader token_endpoint_auth_signing_alg_values_supported: Array[String]
      attr_reader scopes_supported: Array[String]
      attr_reader dpop_signing_alg_values_supported: Array[String]

      def initialize: (Hash[String, untyped] metadata) -> void

      # Fetches and validates Authorization Server metadata from an issuer URL
      # @param issuer [String] Authorization Server issuer URL
      # @return [AuthorizationServer] new instance with fetched metadata
      # @raise [InvalidAuthorizationServer] if metadata is invalid
      def self.from_issuer: (String issuer) -> AuthorizationServer

      private

      def validate_and_set_metadata!: (Hash[String, untyped] metadata) -> void

      def validate_issuer!: (String issuer) -> String

      def validate_https_url!: (String url) -> String

      def validate_response_types!: (Array[String] types) -> void

      def validate_grant_types!: (Array[String] types) -> void

      def validate_code_challenge_methods!: (Array[String] methods) -> void

      def validate_token_endpoint_auth_methods!: (Array[String] methods) -> void

      def validate_token_endpoint_auth_signing_algs!: (Array[String] algs) -> void

      def validate_dpop_signing_algs!: (Array[String] algs) -> void

      def validate_scopes!: (Array[String] scopes) -> void

      def validate_boolean_field!: (Hash[String, untyped] metadata, String field, bool required_value) -> void

      def self.fetch_metadata: (String issuer) -> Hash[Symbol, String]

      def self.parse_metadata: (String body) -> Hash[String, untyped]

      def self.validate_issuer!: (String metadata_issuer, String request_issuer) -> void
    end
  end
end
-----

sig/atproto_auth/server_metadata/origin_url.rbs:
module AtprotoAuth
  module ServerMetadata
    class OriginUrl
      @url: String
      @uri: URI

      attr_reader url: String
      attr_reader uri: URI

      def initialize: (String url) -> void

      def valid?: () -> bool

      private

      def uses_https_scheme?: () -> bool
      def has_root_path?: () -> bool
      def has_explicit_port?: () -> bool
    end
  end
end
-----

sig/atproto_auth/server_metadata/resource_server.rbs:
module AtprotoAuth
  module ServerMetadata
    class ResourceServer
      @authorization_servers: Array[String]

      attr_reader authorization_servers: Array[String]

      def initialize: (Hash[String, untyped] metadata) -> void

      def self.from_url: (String url) -> ResourceServer

      private

      def validate_authorization_servers!: (Array[String] servers) -> Array[String]

      def ensure_servers_exist: (Array[String] | nil) -> void

      def ensure_exactly_one_server: (Array[String]) -> void

      def validate_server_url_format: (String server_url) -> void

      def self.fetch_metadata: (String url) -> Hash[Symbol, String]

      def self.parse_metadata: (String body) -> Hash[String, untyped]
    end
  end
end
-----

sig/atproto_auth/state/session.rbs:
module AtprotoAuth
  module State
    class Session
      @session_id: String
      @state_token: String
      @client_id: String
      @scope: String
      @auth_server: AuthorizationServer?
      @did: String?
      @pkce_verifier: String
      @pkce_challenge: String
      @tokens: TokenSet?

      include MonitorMixin

      attr_reader session_id: String
      attr_reader state_token: String
      attr_reader client_id: String
      attr_reader scope: String
      attr_reader pkce_verifier: String
      attr_reader pkce_challenge: String
      attr_reader auth_server: AuthorizationServer?
      attr_reader did: String?
      attr_reader tokens: TokenSet?

      def initialize: (
          client_id: String,
          scope: String,
          ?auth_server: AuthorizationServer?,
          ?did: String?
        ) -> void

      def authorization_server=: (AuthorizationServer server) -> void

      def did=: (String did) -> void

      def tokens=: (TokenSet tokens) -> void

      def authorized?: () -> bool

      def renewable?: () -> bool

      def validate_state: (String state) -> bool

      private

      def secure_compare: (String str1, String str2) -> bool
    end
  end
end
-----

sig/atproto_auth/state/session_manager.rbs:
module AtprotoAuth
  module State
    class SessionManager
      @sessions: Hash[String, Session]

      include MonitorMixin

      def initialize: () -> void

      def create_session: (
          client_id: String,
          scope: String,
          ?auth_server: ServerMetadata::AuthorizationServer?,
          ?did: String?
        ) -> Session

      def get_session: (String session_id) -> Session?

      def get_session_by_state: (String state) -> Session?

      def remove_session: (String session_id) -> void

      def cleanup_expired: () -> void
    end
  end
end
-----

sig/atproto_auth/state/token_set.rbs:
module AtprotoAuth
  module State
    class TokenSet
      @access_token: String
      @refresh_token: String?
      @token_type: String
      @scope: String
      @sub: String
      @expires_at: Time

      attr_reader access_token: String
      attr_reader refresh_token: String?
      attr_reader token_type: String
      attr_reader scope: String
      attr_reader expires_at: Time
      attr_reader sub: String

      def initialize: (
          access_token: String,
          token_type: String,
          expires_in: Integer,
          scope: String,
          sub: String,
          ?refresh_token: String?
        ) -> void

      def renewable?: () -> bool

      def expired?: (?Integer buffer) -> bool

      private

      def validate_token_type!: (String type) -> void

      def validate_required!: (String name, String? value) -> void

      def validate_expires_in!: (Integer expires_in) -> void
    end
  end
end
-----

sig/atproto_auth/version.rbs:
module AtprotoAuth
  VERSION: String
end
-----

sig/atproto_auth.rbs:
interface _HTTPClient
  def get: (String, ?Hash[Symbol, untyped]) -> { status: Integer, body: String, headers: Hash[String, String] }
  def post: (String, ?Hash[Symbol, untyped]) -> { status: Integer, body: String, headers: Hash[String, String] }
  def put: (String, ?Hash[Symbol, untyped]) -> { status: Integer, body: String, headers: Hash[String, String] }
  def delete: (String, ?Hash[Symbol, untyped]) -> { status: Integer, body: String, headers: Hash[String, String] }
end

module AtprotoAuth
  class Error < StandardError
  end

  class OAuthError
    attr_reader error_code: String

    def initialize: (String message, String error_code) -> void
  end

  class InvalidClientMetadata < OAuthError
    def initialize: (String message) -> void
  end

  class InvalidAuthorizationServer < OAuthError
    def initialize: (String message) -> void
  end

  class Configuration
    attr_accessor default_token_lifetime: Integer
    attr_accessor dpop_nonce_lifetime: Integer
    attr_accessor http_client: _HTTPClient?

    def initialize: () -> void
  end

  attr_writer self.configuration: Configuration

  def self.configuration: () -> Configuration

  def self.configure: () { (Configuration) -> untyped } -> Configuration
end
-----

test/atproto_auth/client_metadata_test.rb:
# frozen_string_literal: true

require_relative "../test_helper"

describe AtprotoAuth::ClientMetadata do
  before do
    @valid_metadata = {
      "client_id" => "https://example.com/metadata.json",
      "grant_types" => %w[authorization_code refresh_token],
      "response_types" => ["code"],
      "redirect_uris" => ["https://example.com/callback"],
      "scope" => "atproto offline_access",
      "dpop_bound_access_tokens" => true,
      "client_name" => "Example Client",
      "application_type" => "web"
    }
  end

  describe "initialization" do
    it "initializes with valid metadata" do
      client_metadata = AtprotoAuth::ClientMetadata.new(@valid_metadata)
      _(client_metadata.client_id).must_equal "https://example.com/metadata.json"
      _(client_metadata.grant_types).must_equal %w[authorization_code refresh_token]
      _(client_metadata.response_types).must_equal ["code"]
      _(client_metadata.redirect_uris).must_equal ["https://example.com/callback"]
      _(client_metadata.scope).must_equal "atproto offline_access"
      _(client_metadata.client_name).must_equal "Example Client"
      _(client_metadata.application_type).must_equal "web"
    end

    it "initializes with localhost client_id" do
      @valid_metadata["client_id"] = "http://localhost"
      @valid_metadata["redirect_uris"] = ["http://127.0.0.1:9292/callback"]
      client_metadata = AtprotoAuth::ClientMetadata.new(@valid_metadata)
      _(client_metadata.client_id).must_equal "http://localhost"
    end

    it "raises an error when client_id is missing" do
      @valid_metadata.delete("client_id")
      _(-> { AtprotoAuth::ClientMetadata.new(@valid_metadata) }).must_raise AtprotoAuth::InvalidClientMetadata
    end

    it "raises an error for invalid client_id scheme" do
      @valid_metadata["client_id"] = "http://example.com"
      _(-> { AtprotoAuth::ClientMetadata.new(@valid_metadata) }).must_raise AtprotoAuth::InvalidClientMetadata
    end

    it "raises an error for invalid grant types" do
      @valid_metadata["grant_types"] = ["invalid_grant"]
      _(-> { AtprotoAuth::ClientMetadata.new(@valid_metadata) }).must_raise AtprotoAuth::InvalidClientMetadata
    end

    it "raises an error when redirect URIs are missing" do
      @valid_metadata.delete("redirect_uris")
      _(-> { AtprotoAuth::ClientMetadata.new(@valid_metadata) }).must_raise AtprotoAuth::InvalidClientMetadata
    end

    it "raises an error for invalid redirect URI scheme" do
      @valid_metadata["redirect_uris"] = ["http://example.com/callback"]
      _(-> { AtprotoAuth::ClientMetadata.new(@valid_metadata) }).must_raise AtprotoAuth::InvalidClientMetadata
    end

    it "raises an error for invalid scope" do
      @valid_metadata["scope"] = "invalid_scope"
      _(-> { AtprotoAuth::ClientMetadata.new(@valid_metadata) }).must_raise AtprotoAuth::InvalidClientMetadata
    end

    it "raises an error for missing dpop_bound_access_tokens" do
      @valid_metadata.delete("dpop_bound_access_tokens")
      _(-> { AtprotoAuth::ClientMetadata.new(@valid_metadata) }).must_raise AtprotoAuth::InvalidClientMetadata
    end
  end

  describe ".from_url" do
    it "creates an instance from valid URL metadata" do
      AtprotoAuth::ClientMetadata.stubs(:fetch_metadata).returns({ body: @valid_metadata.to_json })
      client_metadata = AtprotoAuth::ClientMetadata.from_url("https://example.com/metadata.json")
      _(client_metadata).must_be_instance_of AtprotoAuth::ClientMetadata
      _(client_metadata.client_id).must_equal "https://example.com/metadata.json"
    end

    it "raises an error for invalid URL scheme" do
      _(lambda {
        AtprotoAuth::ClientMetadata.from_url("http://example.com/metadata")
      }).must_raise AtprotoAuth::InvalidClientMetadata
    end

    it "raises an error for client_id mismatch in metadata" do
      AtprotoAuth::ClientMetadata.stubs(:fetch_metadata).returns({ body: @valid_metadata.to_json })
      @valid_metadata["client_id"] = "https://otherexample.com"
      _(lambda {
        AtprotoAuth::ClientMetadata.from_url("https://example.com/metadata")
      }).must_raise AtprotoAuth::InvalidClientMetadata
    end
  end

  describe "#confidential?" do
    it "returns true for confidential clients using private_key_jwt" do
      @valid_metadata["token_endpoint_auth_method"] = "private_key_jwt"
      @valid_metadata["token_endpoint_auth_signing_alg"] = "ES256"
      @valid_metadata["jwks"] = { "keys" => [] }
      client_metadata = AtprotoAuth::ClientMetadata.new(@valid_metadata)
      _(client_metadata.confidential?).must_equal true
    end

    it "returns false for non-confidential clients" do
      client_metadata = AtprotoAuth::ClientMetadata.new(@valid_metadata)
      _(client_metadata.confidential?).must_equal false
    end
  end
end
-----

test/atproto_auth/configuration_test.rb:
# frozen_string_literal: true

require_relative "../test_helper"

describe AtprotoAuth::Configuration do
  let(:configuration) { AtprotoAuth::Configuration.new }

  describe "#initialize" do
    it "sets default values" do
      _(configuration.default_token_lifetime).must_equal 300
      _(configuration.dpop_nonce_lifetime).must_equal 300
      _(configuration.logger).must_be_instance_of Logger
      _(configuration.storage).must_be_instance_of AtprotoAuth::Storage::Memory
    end
  end

  describe "#validate!" do
    it "validates valid configuration" do
      _(configuration.validate!).must_equal true
    end

    it "validates custom storage implementation" do
      custom_storage = Class.new(AtprotoAuth::Storage::Interface) do
        def set(key, value, ttl: nil); end
        def get(key); end
        def delete(key); end
        def exists?(key); end
        def multi_get(keys); end
        def multi_set(hash, ttl: nil); end
        def acquire_lock(key, ttl:); end
        def release_lock(key); end
        def with_lock(key, ttl: 30); end
      end.new

      configuration.storage = custom_storage
      _(configuration.validate!).must_equal true
    end

    it "raises error for invalid storage implementation" do
      configuration.storage = Object.new
      assert_raises(AtprotoAuth::ConfigurationError) do
        configuration.validate!
      end
    end

    it "raises error for nil storage" do
      configuration.storage = nil
      assert_raises(AtprotoAuth::ConfigurationError) do
        configuration.validate!
      end
    end

    it "validates http client interface" do
      valid_client = Object.new
      def valid_client.get(url, headers = {}); end
      def valid_client.post(url, body: nil, headers: {}); end

      configuration.http_client = valid_client
      _(configuration.validate!).must_equal true
    end

    it "raises error for invalid http client" do
      configuration.http_client = Object.new
      assert_raises(AtprotoAuth::ConfigurationError) do
        configuration.validate!
      end
    end
  end
end
-----

test/atproto_auth/dpop/client_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"

describe AtprotoAuth::DPoP::Client do
  let(:mock_key_manager) do
    Class.new(AtprotoAuth::DPoP::KeyManager) do
      def initialize; end # rubocop:disable Lint/MissingSuper - prevent calling actual KeyManager initialization logic
      def public_jwk = { kty: "EC", crv: "P-256", x: "test", y: "test" }
      def sign(_jwt_payload) = "signed_jwt"
    end.new
  end

  let(:client) do
    AtprotoAuth::DPoP::Client.new(
      key_manager: mock_key_manager,
      nonce_ttl: 400
    )
  end
  let(:http_method) { "POST" }
  let(:http_uri) { "https://example.com/resource" }
  let(:nonce) { "valid_nonce" }
  let(:access_token) { "test_access_token" }
  let(:server_url) { "https://example.com" }
  let(:proof) { "dpop_proof_jwt" }
  let(:response_headers) { { "DPoP-Nonce" => nonce } }

  describe "#initialize" do
    it "initializes with a custom key_manager and nonce_ttl" do
      _(client.key_manager).must_equal mock_key_manager
      _(client.nonce_manager.instance_variable_get(:@ttl)).must_equal 400
    end
  end

  describe "#generate_proof" do
    it "generates a DPoP proof using proof_generator" do
      client.nonce_manager.expects(:get).with("https://example.com").returns(nonce)
      client.proof_generator.expects(:generate).with(
        http_method: http_method,
        http_uri: http_uri,
        nonce: nonce,
        access_token: access_token
      ).returns(proof)

      generated_proof = client.generate_proof(http_method: http_method, http_uri: http_uri, access_token: access_token)
      _(generated_proof).must_equal proof
    end

    it "raises an error if proof generation fails" do
      client.nonce_manager.expects(:get).with("https://example.com").returns(nil)
      client.proof_generator.expects(:generate).raises(StandardError, "Generation failed")

      assert_raises(AtprotoAuth::DPoP::Client::Error) do
        client.generate_proof(http_method: http_method, http_uri: http_uri)
      end
    end
  end

  describe "#process_response" do
    it "updates the nonce manager with a valid nonce" do
      client.nonce_manager.expects(:update).with(nonce: nonce, server_url: server_url)

      client.process_response(response_headers, server_url)
    end

    it "does nothing if the response headers do not include a nonce" do
      headers = {}
      client.nonce_manager.expects(:update).never

      client.process_response(headers, server_url)
    end

    it "raises an error if nonce update fails" do
      client.nonce_manager.expects(:update).raises(StandardError, "Update failed")

      assert_raises(AtprotoAuth::DPoP::Client::Error) do
        client.process_response(response_headers, server_url)
      end
    end
  end

  describe "#request_headers" do
    it "constructs the DPoP headers with the proof" do
      headers = client.request_headers(proof)
      _(headers).must_equal({ "DPoP" => proof })
    end
  end

  describe "#public_key" do
    it "returns the public JWK from key_manager" do
      mock_key_manager.expects(:public_jwk).returns({ "kty" => "EC", "crv" => "P-256" })

      _(client.public_key).must_equal({ "kty" => "EC", "crv" => "P-256" })
    end
  end

  describe "#export_key" do
    it "exports the keypair with the private key" do
      mock_key_manager.expects(:to_jwk).with(include_private: true).returns({ "kty" => "EC", "d" => "private" })

      _(client.export_key(include_private: true)).must_equal({ "kty" => "EC", "d" => "private" })
    end

    it "exports the keypair without the private key" do
      mock_key_manager.expects(:to_jwk).with(include_private: false).returns({ "kty" => "EC" })

      _(client.export_key(include_private: false)).must_equal({ "kty" => "EC" })
    end
  end
end
-----

test/atproto_auth/dpop/key_manager_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"

describe AtprotoAuth::DPoP::KeyManager do
  let(:valid_keypair) { JOSE::JWK.generate_key([:ec, "P-256"]) }
  let(:invalid_keypair) { JOSE::JWK.generate_key([:rsa, 2048]) }

  describe "#initialize" do
    it "creates a KeyManager with a valid EC keypair" do
      manager = AtprotoAuth::DPoP::KeyManager.new(valid_keypair)
      assert_equal valid_keypair, manager.keypair
    end

    it "raises an error when initialized with an invalid keypair" do
      assert_raises(AtprotoAuth::DPoP::KeyManager::KeyError) do
        AtprotoAuth::DPoP::KeyManager.new(invalid_keypair)
      end
    end

    it "generates a new keypair if none is provided" do
      manager = AtprotoAuth::DPoP::KeyManager.new
      keypair = manager.keypair
      assert_equal "EC", keypair.to_map["kty"]
      assert_equal "P-256", keypair.to_map["crv"]
    end
  end

  describe "#generate_keypair" do
    it "generates a valid ES256 keypair" do
      manager = AtprotoAuth::DPoP::KeyManager.new
      keypair = manager.generate_keypair
      assert_equal "EC", keypair.to_map["kty"]
      assert_equal "P-256", keypair.to_map["crv"]
    end
  end

  describe "#public_jwk" do
    it "returns the public key in JWK format" do
      manager = AtprotoAuth::DPoP::KeyManager.new(valid_keypair)
      public_jwk = manager.public_jwk
      assert_equal "EC", public_jwk["kty"]
      assert_equal "P-256", public_jwk["crv"]
    end
  end

  describe "#sign" do
    it "signs data using the private key" do
      manager = AtprotoAuth::DPoP::KeyManager.new(valid_keypair)
      data = "test_data"
      signature = manager.sign(data)
      assert_instance_of JOSE::SignedBinary, signature
    end
  end

  describe "#verify" do
    it "verifies a signed JWS" do
      manager = AtprotoAuth::DPoP::KeyManager.new(valid_keypair)
      data = "test_data"
      signature = manager.sign(data)
      assert manager.verify(signature)
    end

    it "raises an error if verification fails" do
      manager = AtprotoAuth::DPoP::KeyManager.new(valid_keypair)
      invalid_signature = "invalid_signature"
      assert_raises(AtprotoAuth::DPoP::KeyManager::KeyError) do
        manager.verify(invalid_signature)
      end
    end
  end

  describe "#to_jwk" do
    it "exports the keypair in JWK format including private key" do
      manager = AtprotoAuth::DPoP::KeyManager.new(valid_keypair)
      jwk = manager.to_jwk(include_private: true)
      assert_equal "EC", jwk["kty"]
      assert_equal "P-256", jwk["crv"]
      assert jwk.key?("d")
    end

    it "exports the public key only when include_private is false" do
      manager = AtprotoAuth::DPoP::KeyManager.new(valid_keypair)
      jwk = manager.to_jwk(include_private: false)
      assert_equal "EC", jwk["kty"]
      assert_equal "P-256", jwk["crv"]
      refute jwk.key?("d")
    end
  end

  describe ".from_jwk" do
    it "creates a KeyManager instance from a JWK" do
      manager = AtprotoAuth::DPoP::KeyManager.from_jwk(valid_keypair.to_map)
      assert_instance_of AtprotoAuth::DPoP::KeyManager, manager
    end

    it "raises an error if importing the JWK fails" do
      invalid_jwk = { "kty" => "RSA", "n" => "mocked_n", "e" => "mocked_e" }
      assert_raises(AtprotoAuth::DPoP::KeyManager::KeyError) do
        AtprotoAuth::DPoP::KeyManager.from_jwk(invalid_jwk)
      end
    end
  end
end
-----

test/atproto_auth/dpop/nonce_manager_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"

describe AtprotoAuth::DPoP::NonceManager do
  let(:server_url) { "https://example.com" }
  let(:invalid_server_url) { "http://example.com" }
  let(:nonce) { "valid_nonce" }
  let(:expired_nonce) { "expired_nonce" }
  let(:ttl) { 2 } # Custom TTL for testing expiration
  let(:nonce_manager) { AtprotoAuth::DPoP::NonceManager.new(ttl: ttl) }

  after do
    nonce_manager.clear(server_url)
  end

  describe "#initialize" do
    it "initializes with a default TTL" do
      manager = AtprotoAuth::DPoP::NonceManager.new
      _(manager.instance_variable_get(:@ttl)).must_equal AtprotoAuth::DPoP::NonceManager::DEFAULT_TTL
    end

    it "initializes with a custom TTL" do
      _(nonce_manager.instance_variable_get(:@ttl)).must_equal ttl
    end
  end

  describe "#update" do
    it "stores a nonce for a server" do
      nonce_manager.update(nonce: nonce, server_url: server_url)
      stored = nonce_manager.get(server_url)
      _(stored).must_equal nonce
    end

    it "updates an existing nonce" do
      nonce_manager.update(nonce: nonce, server_url: server_url)
      nonce_manager.update(nonce: "new_nonce", server_url: server_url)
      _(nonce_manager.get(server_url)).must_equal "new_nonce"
    end

    it "stores nonce for non-HTTPS localhost server" do
      nonce_manager.update(nonce: nonce, server_url: "http://localhost:3000")
      stored = nonce_manager.get("http://localhost:3000")
      _(stored).must_equal nonce
    end

    it "raises an error if nonce is invalid" do
      assert_raises(AtprotoAuth::DPoP::NonceManager::NonceError) do
        nonce_manager.update(nonce: "", server_url: server_url)
      end
    end

    it "raises an error if server_url is invalid" do
      assert_raises(AtprotoAuth::DPoP::NonceManager::NonceError) do
        nonce_manager.update(nonce: nonce, server_url: invalid_server_url)
      end
    end
  end

  describe "#get" do
    it "returns the current nonce for a server" do
      nonce_manager.update(nonce: nonce, server_url: server_url)
      _(nonce_manager.get(server_url)).must_equal nonce
    end

    it "returns nil if no nonce exists for the server" do
      _(nonce_manager.get(server_url)).must_equal nil
    end

    it "returns nil if the nonce has expired" do
      nonce_manager.update(nonce: expired_nonce, server_url: server_url)
      sleep(ttl + 0.1) # Wait for expiration
      _(nonce_manager.get(server_url)).must_be_nil
    end

    it "raises an error if server_url is invalid" do
      assert_raises(AtprotoAuth::DPoP::NonceManager::NonceError) do
        nonce_manager.get("")
      end
    end
  end

  describe "#clear" do
    it "removes a nonce for a server" do
      nonce_manager.update(nonce: nonce, server_url: server_url)
      nonce_manager.clear(server_url)
      _(nonce_manager.get(server_url)).must_be_nil
    end
  end

  describe "#valid_nonce?" do
    it "returns true if the server has a valid nonce" do
      nonce_manager.update(nonce: nonce, server_url: server_url)
      _(nonce_manager.valid_nonce?(server_url)).must_equal true
    end

    it "returns false if no nonce exists for the server" do
      _(nonce_manager.valid_nonce?(server_url)).must_equal false
    end

    it "returns false if the nonce has expired" do
      nonce_manager.update(nonce: expired_nonce, server_url: server_url)
      sleep(ttl + 0.1) # Wait for expiration
      _(nonce_manager.valid_nonce?(server_url)).must_equal false
    end

    it "raises an error if server_url is invalid" do
      assert_raises(AtprotoAuth::DPoP::NonceManager::NonceError) do
        nonce_manager.valid_nonce?("")
      end
    end
  end

  describe "thread safety" do
    it "handles concurrent nonce updates" do
      threads = 10.times.map do |i|
        Thread.new do
          nonce_manager.update(nonce: "nonce_#{i}", server_url: server_url)
          sleep(0.1)
          nonce_manager.get(server_url)
        end
      end

      threads.each(&:join)
      # The nonce should exist and be one of the values we set
      stored = nonce_manager.get(server_url)
      assert stored =~ /^nonce_\d$/
    end
  end
end
-----

test/atproto_auth/dpop/proof_generator_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"

UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i

describe AtprotoAuth::DPoP::ProofGenerator do
  let(:key_manager) { AtprotoAuth::DPoP::KeyManager.new }
  let(:generator) { AtprotoAuth::DPoP::ProofGenerator.new(key_manager) }
  let(:http_method) { "POST" }
  let(:http_uri) { "https://example.com/path" }

  describe "initialization" do
    it "requires a key manager" do
      assert_raises(AtprotoAuth::DPoP::ProofGenerator::ProofError) do
        AtprotoAuth::DPoP::ProofGenerator.new(nil)
      end
    end

    it "validates key manager type" do
      assert_raises(AtprotoAuth::DPoP::ProofGenerator::ProofError) do
        AtprotoAuth::DPoP::ProofGenerator.new("invalid")
      end
    end
  end

  describe "#generate" do
    it "generates valid proof JWT" do
      proof = generator.generate(http_method: http_method, http_uri: http_uri)
      segments = proof.split(".")
      assert_equal 3, segments.length # header.payload.signature

      header = JSON.parse(Base64.urlsafe_decode64(segments[0]))
      payload = JSON.parse(Base64.urlsafe_decode64(segments[1]))

      assert_equal "dpop+jwt", header["typ"]
      assert_equal "ES256", header["alg"]
      assert_kind_of Hash, header["jwk"]

      assert_match UUID_REGEX, payload["jti"]
      assert_equal http_method, payload["htm"]
      assert_equal http_uri, payload["htu"]
      assert_kind_of Integer, payload["iat"]
    end

    it "includes nonce when provided" do
      nonce = SecureRandom.hex
      proof = generator.generate(
        http_method: http_method,
        http_uri: http_uri,
        nonce: nonce
      )
      payload = extract_payload(proof)
      assert_equal nonce, payload["nonce"]
    end

    it "optionally includes access token hash" do
      token = "test_token"
      proof = generator.generate(
        http_method: http_method,
        http_uri: http_uri,
        access_token: token,
        ath: true
      )
      payload = extract_payload(proof)

      digest = OpenSSL::Digest::SHA256.digest(token)
      expected_hash = Base64.urlsafe_encode64(digest[0...(digest.length / 2)], padding: false)
      assert_equal expected_hash, payload["ath"]
    end

    it "normalizes URIs" do
      uri = "https://example.com:443/path?query#fragment"
      proof = generator.generate(http_method: http_method, http_uri: uri)
      payload = extract_payload(proof)
      assert_equal "https://example.com/path?query", payload["htu"]
    end

    it "validates http method" do
      assert_raises(AtprotoAuth::DPoP::ProofGenerator::ProofError) do
        generator.generate(http_method: "", http_uri: http_uri)
      end
    end

    it "validates http uri" do
      assert_raises(AtprotoAuth::DPoP::ProofGenerator::ProofError) do
        generator.generate(http_method: http_method, http_uri: "invalid")
      end
    end

    it "requires https or http uri" do
      assert_raises(AtprotoAuth::DPoP::ProofGenerator::ProofError) do
        generator.generate(http_method: http_method, http_uri: "ftp://example.com")
      end
    end
  end

  private

  def extract_payload(proof)
    payload = proof.split(".")[1]
    JSON.parse(Base64.urlsafe_decode64(payload))
  end
end
-----

test/atproto_auth/encryption_test.rb:
# frozen_string_literal: true

require_relative "../test_helper"

describe AtprotoAuth::Encryption do
  describe AtprotoAuth::Encryption::Service do
    let(:encryption_service) { AtprotoAuth::Encryption::Service.new }
    let(:sample_data) { "sensitive data" }
    let(:context) { "access_token" }

    describe "#encrypt" do
      it "encrypts data with a context" do
        result = encryption_service.encrypt(sample_data, context: context)

        assert_equal AtprotoAuth::Encryption::Service::VERSION, result[:version]
        assert_kind_of String, result[:iv]
        assert_kind_of String, result[:data]
        assert_kind_of String, result[:tag]

        # Base64 validation
        assert Base64.strict_decode64(result[:iv])
        assert Base64.strict_decode64(result[:data])
        assert Base64.strict_decode64(result[:tag])
      end

      it "produces different ciphertexts for same data with different contexts" do
        result1 = encryption_service.encrypt(sample_data, context: "context1")
        result2 = encryption_service.encrypt(sample_data, context: "context2")

        refute_equal result1[:data], result2[:data]
      end

      it "produces different ciphertexts for same data and context due to IV" do
        result1 = encryption_service.encrypt(sample_data, context: context)
        result2 = encryption_service.encrypt(sample_data, context: context)

        refute_equal result1[:data], result2[:data]
        refute_equal result1[:iv], result2[:iv]
      end

      it "raises EncryptionError for nil data" do
        assert_raises(AtprotoAuth::Encryption::EncryptionError, "Data cannot be nil") do
          encryption_service.encrypt(nil, context: context)
        end
      end

      it "raises EncryptionError for nil context" do
        assert_raises(AtprotoAuth::Encryption::EncryptionError, "Context cannot be nil") do
          encryption_service.encrypt(sample_data, context: nil)
        end
      end

      it "raises EncryptionError for empty context" do
        assert_raises(AtprotoAuth::Encryption::EncryptionError, "Context cannot be empty") do
          encryption_service.encrypt(sample_data, context: "")
        end
      end

      it "converts non-string data to string" do
        result = encryption_service.encrypt(123, context: context)
        decrypted = encryption_service.decrypt(result, context: context)
        assert_equal "123", decrypted
      end
    end

    describe "#decrypt" do
      it "correctly decrypts encrypted data" do
        encrypted = encryption_service.encrypt(sample_data, context: context)
        decrypted = encryption_service.decrypt(encrypted, context: context)

        assert_equal sample_data, decrypted
      end

      it "raises DecryptionError for wrong context" do
        encrypted = encryption_service.encrypt(sample_data, context: context)

        assert_raises(AtprotoAuth::Encryption::DecryptionError) do
          encryption_service.decrypt(encrypted, context: "wrong_context")
        end
      end

      it "raises DecryptionError for tampered data" do
        encrypted = encryption_service.encrypt(sample_data, context: context)
        encrypted[:data] = Base64.strict_encode64("tampered")

        assert_raises(AtprotoAuth::Encryption::DecryptionError) do
          encryption_service.decrypt(encrypted, context: context)
        end
      end

      it "raises DecryptionError for tampered auth tag" do
        encrypted = encryption_service.encrypt(sample_data, context: context)
        encrypted[:tag] = Base64.strict_encode64("tampered")

        assert_raises(AtprotoAuth::Encryption::DecryptionError) do
          encryption_service.decrypt(encrypted, context: context)
        end
      end

      it "raises DecryptionError for nil encrypted data" do
        assert_raises(AtprotoAuth::Encryption::DecryptionError, "Encrypted data cannot be nil") do
          encryption_service.decrypt(nil, context: context)
        end
      end

      it "raises DecryptionError for nil context" do
        encrypted = encryption_service.encrypt(sample_data, context: context)
        assert_raises(AtprotoAuth::Encryption::DecryptionError, "Context cannot be nil") do
          encryption_service.decrypt(encrypted, context: nil)
        end
      end

      it "raises DecryptionError for invalid format" do
        assert_raises(AtprotoAuth::Encryption::DecryptionError) do
          encryption_service.decrypt({ invalid: "format" }, context: context)
        end
      end

      it "raises DecryptionError for wrong version" do
        encrypted = encryption_service.encrypt(sample_data, context: context)
        encrypted[:version] = 999

        assert_raises(AtprotoAuth::Encryption::DecryptionError) do
          encryption_service.decrypt(encrypted, context: context)
        end
      end
    end
  end

  describe AtprotoAuth::Encryption::KeyProvider do
    let(:key_provider) { AtprotoAuth::Encryption::KeyProvider.new }

    describe "#key_for_context" do
      it "derives different keys for different contexts" do
        key1 = key_provider.key_for_context("context1")
        key2 = key_provider.key_for_context("context2")

        refute_equal key1, key2
      end

      it "derives consistent keys for same context" do
        key1 = key_provider.key_for_context("context")
        key2 = key_provider.key_for_context("context")

        assert_equal key1, key2
      end

      it "returns keys of correct length for AES-256" do
        key = key_provider.key_for_context("context")
        assert_equal 32, key.bytesize
      end

      it "raises ConfigurationError for nil context" do
        assert_raises(AtprotoAuth::Encryption::ConfigurationError) do
          key_provider.key_for_context(nil)
        end
      end
    end
  end
end
-----

test/atproto_auth/http_client_test.rb:
# frozen_string_literal: true

require_relative "../test_helper"

describe AtprotoAuth::HttpClient do
  let(:client) { AtprotoAuth::HttpClient.new }
  let(:sample_url) { "https://example.com/resource" }
  let(:private_ip) { "192.168.1.1" }

  describe "request validation" do
    it "rejects non-HTTPS URLs" do
      assert_raises(AtprotoAuth::HttpClient::SSRFError) do
        client.get("http://example.com")
      end
    end

    it "rejects URLs with fragments" do
      assert_raises(AtprotoAuth::HttpClient::SSRFError) do
        client.get("https://example.com#fragment")
      end
    end

    it "rejects URLs without hosts" do
      assert_raises(AtprotoAuth::HttpClient::SSRFError) do
        client.get("https:///resource")
      end
    end

    it "rejects private network IPs" do
      stub_request(:get, "https://#{private_ip}/")
        .to_return(status: 200, body: "")

      assert_raises(AtprotoAuth::HttpClient::SSRFError) do
        client.get("https://#{private_ip}/")
      end
    end
  end

  describe "#get" do
    before do
      stub_request(:get, sample_url)
        .to_return(status: 200, body: "success", headers: { "Content-Type" => "text/plain" })
    end

    it "makes successful GET requests" do
      response = client.get(sample_url)
      assert_equal 200, response[:status]
      assert_equal "success", response[:body]
    end

    it "includes security headers" do
      stub_request(:get, sample_url)
        .with(headers: { "Cache-Control" => "no-store" })
        .to_return(status: 200, body: "")

      client.get(sample_url)
      assert_requested :get, sample_url, headers: { "Cache-Control" => "no-store" }
    end

    it "forwards user headers" do
      custom_headers = { "X-Custom" => "value" }

      stub_request(:get, sample_url)
        .with(headers: custom_headers)
        .to_return(status: 200, body: "")

      client.get(sample_url, custom_headers)
      assert_requested :get, sample_url, headers: custom_headers
    end

    it "follows redirects up to limit" do
      redirect_url = "https://example.com/final"

      stub_request(:get, sample_url)
        .to_return(status: 302, headers: { "Location" => redirect_url })
      stub_request(:get, redirect_url)
        .to_return(status: 200, body: "redirected")

      response = client.get(sample_url)
      assert_equal "redirected", response[:body]
    end

    it "prevents redirect loops" do
      stub_request(:get, sample_url)
        .to_return(status: 302, headers: { "Location" => sample_url })

      assert_raises(AtprotoAuth::HttpClient::HttpError) do
        client.get(sample_url)
      end
    end

    it "rejects oversized responses" do
      large_response = "x" * (AtprotoAuth::HttpClient::MAX_RESPONSE_SIZE + 1)

      stub_request(:get, sample_url)
        .to_return(status: 200, body: large_response)

      assert_raises(AtprotoAuth::HttpClient::HttpError) do
        client.get(sample_url)
      end
    end
  end

  describe "#post" do
    let(:post_body) { "request body" }
    let(:post_headers) { { "Content-Type" => "text/plain" } }

    before do
      stub_request(:post, sample_url)
        .to_return(status: 201, body: "created")
    end

    it "makes successful POST requests" do
      response = client.post(sample_url, body: post_body, headers: post_headers)
      assert_equal 201, response[:status]
      assert_equal "created", response[:body]
    end

    it "sends request body" do
      stub_request(:post, sample_url)
        .with(body: post_body)
        .to_return(status: 201)

      client.post(sample_url, body: post_body)
      assert_requested :post, sample_url, body: post_body
    end

    it "handles POST redirects" do
      redirect_url = "https://example.com/final"

      stub_request(:post, sample_url)
        .with(body: post_body)
        .to_return(status: 307, headers: { "Location" => redirect_url })
      stub_request(:post, redirect_url)
        .with(body: post_body)
        .to_return(status: 201, body: "redirected")

      response = client.post(sample_url, body: post_body)
      assert_equal "redirected", response[:body]
      assert_requested :post, redirect_url, body: post_body
    end
    #
    # it "handles POST redirects" do
    #   redirect_url = "https://example.com/final"
    #
    #   stub_request(:post, sample_url).
    #     to_return(status: 307, headers: {"Location" => redirect_url})
    #   stub_request(:post, redirect_url).
    #     to_return(status: 201, body: "redirected")
    #
    #   response = client.post(sample_url, body: post_body)
    #   assert_equal "redirected", response[:body]
    #   assert_requested :post, redirect_url
    # end

    it "includes security headers in POST requests" do
      stub_request(:post, sample_url)
        .with(headers: { "Cache-Control" => "no-store" })
        .to_return(status: 201)

      client.post(sample_url)
      assert_requested :post, sample_url, headers: { "Cache-Control" => "no-store" }
    end
  end

  describe "timeout handling" do
    let(:client) { AtprotoAuth::HttpClient.new(timeout: 1) }

    it "handles read timeouts" do
      stub_request(:get, sample_url).to_timeout

      assert_raises(AtprotoAuth::HttpClient::HttpError) do
        client.get(sample_url)
      end
    end
  end

  describe "SSL verification" do
    it "verifies SSL certificates by default" do
      client = AtprotoAuth::HttpClient.new
      http = Net::HTTP.new("example.com")
      client.send(:configure_http_client!, http)
      assert_equal OpenSSL::SSL::VERIFY_PEER, http.verify_mode
    end

    it "can disable SSL verification" do
      client = AtprotoAuth::HttpClient.new(verify_ssl: false)
      http = Net::HTTP.new("example.com")
      client.send(:configure_http_client!, http)
      assert_equal OpenSSL::SSL::VERIFY_NONE, http.verify_mode
    end
  end
end
-----

test/atproto_auth/identity/document_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"

describe AtprotoAuth::Identity::Document do
  let(:valid_data) do
    {
      "id" => "did:plc:abc123",
      "verificationMethod" => [{ "publicKeyMultibase" => "z123" }],
      "alsoKnownAs" => ["at://alice.example.com"],
      "pds" => "https://pds.example.com"
    }
  end

  let(:legacy_data) do
    {
      "id" => "did:plc:abc123",
      "service" => [
        {
          "id" => "#atproto_pds",
          "type" => "AtprotoPersonalDataServer",
          "serviceEndpoint" => "https://pds.example.com"
        }
      ]
    }
  end

  let(:invalid_data_no_id) { { "verificationMethod" => [] } }
  let(:invalid_did) { { "id" => "invalid:plc:123" } }
  let(:invalid_service_format) do
    {
      "id" => "did:plc:abc123",
      "service" => [{ "id" => "#svc", "type" => "ServiceType" }]
    }
  end

  describe "#initialize" do
    it "initializes with valid data" do
      doc = AtprotoAuth::Identity::Document.new(valid_data)
      _(doc.did).must_equal "did:plc:abc123"
      _(doc.rotation_keys).must_equal ["z123"]
      _(doc.also_known_as).must_equal ["at://alice.example.com"]
      _(doc.pds).must_equal "https://pds.example.com"
    end

    it "initializes with legacy data format" do
      doc = AtprotoAuth::Identity::Document.new(legacy_data)
      _(doc.did).must_equal "did:plc:abc123"
      _(doc.rotation_keys).must_equal []
      _(doc.also_known_as).must_equal []
      _(doc.pds).must_equal "https://pds.example.com"
    end

    it "raises an error if data is missing id" do
      assert_raises(AtprotoAuth::Identity::DocumentError, "Document must have id") do
        AtprotoAuth::Identity::Document.new(invalid_data_no_id)
      end
    end

    it "raises an error if DID format is invalid" do
      assert_raises(AtprotoAuth::Identity::DocumentError, "Invalid DID format (must be did:plc:)") do
        AtprotoAuth::Identity::Document.new(invalid_did)
      end
    end

    it "raises an error if service entry format is invalid" do
      assert_raises(AtprotoAuth::Identity::DocumentError, "Invalid service entry format") do
        AtprotoAuth::Identity::Document.new(invalid_service_format)
      end
    end
  end

  describe "#has_handle?" do
    let(:doc) { AtprotoAuth::Identity::Document.new(valid_data) }

    it "returns true if handle is present in alsoKnownAs" do
      _(doc.has_handle?("alice.example.com")).must_equal true
    end

    it "returns true if handle with @ prefix is present in alsoKnownAs" do
      _(doc.has_handle?("@alice.example.com")).must_equal true
    end

    it "returns false if handle is not present in alsoKnownAs" do
      _(doc.has_handle?("bob.example.com")).must_equal false
    end
  end
end
-----

test/atproto_auth/identity/resolver_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"

describe AtprotoAuth::Identity::Resolver do
  let(:resolver) { AtprotoAuth::Identity::Resolver.new }
  let(:handle) { "user.test.com" }
  let(:did) { "did:plc:test123" }
  let(:pds_url) { "https://pds.test.com" }
  before do
    AtprotoAuth.configure do |configuration|
      configuration.http_client = AtprotoAuth::HttpClient.new
    end
  end

  describe "#resolve_handle" do
    it "resolves handle via DNS" do
      stub_dns_records(["did=#{did}"])
      stub_plc_document(did, pds_url)

      result = resolver.resolve_handle(handle)
      assert_equal did, result[:did]
      assert_equal pds_url, result[:pds]
    end

    it "falls back to HTTP resolution" do
      stub_dns_empty
      stub_request(:get, "https://#{handle}/.well-known/atproto-did")
        .to_return(body: did)
      stub_plc_document(did, pds_url)

      result = resolver.resolve_handle(handle)
      assert_equal did, result[:did]
    end

    it "handles @ prefix in handle" do
      result = resolver.send(:normalize_handle, "@user.test.com")
      assert_equal "user.test.com", result
    end

    it "validates handle format" do
      assert_raises(AtprotoAuth::Identity::ResolutionError) do
        resolver.resolve_handle("invalid handle")
      end
    end
  end

  describe "#get_did_info" do
    it "fetches and validates DID document" do
      stub_plc_document(did, pds_url)

      result = resolver.get_did_info(did)
      assert_equal did, result[:did]
      assert_equal pds_url, result[:pds]
    end

    it "requires HTTPS for PDS URL" do
      stub_plc_document(did, "http://insecure.com")

      assert_raises(AtprotoAuth::Identity::ResolutionError) do
        resolver.get_did_info(did)
      end
    end

    it "validates DID format" do
      assert_raises(AtprotoAuth::Identity::ResolutionError) do
        resolver.get_did_info("invalid:did")
      end
    end
  end

  describe "#verify_pds_binding" do
    it "verifies PDS hosts DID" do
      stub_plc_document(did, pds_url)

      assert resolver.verify_pds_binding(did, pds_url)
    end

    it "normalizes URLs for comparison" do
      stub_plc_document(did, pds_url)

      assert resolver.verify_pds_binding(did, "#{pds_url}/")
    end
  end

  describe "#verify_issuer_binding" do
    let(:issuer) { "https://auth.test.com" }

    it "verifies issuer is authorized for DID" do
      stub_plc_document(did, pds_url)
      stub_resource_server_metadata(pds_url, issuer)

      assert resolver.verify_issuer_binding(did, issuer)
    end
  end

  describe "#verify_handle_binding" do
    it "verifies handle belongs to DID" do
      doc = {
        "id" => did,
        "alsoKnownAs" => ["at://#{handle}"],
        "pds" => pds_url
      }
      stub_request(:get, "#{resolver.instance_variable_get(:@plc_directory)}/#{did}")
        .to_return(body: doc.to_json)

      assert resolver.verify_handle_binding(handle, did)
    end
  end

  private

  def stub_dns_records(records)
    Resolv::DNS.stubs(:new).returns(mock_resolver(records))
  end

  def stub_dns_empty
    Resolv::DNS.stubs(:new).returns(mock_resolver([]))
  end

  def mock_resolver(records)
    resolver = Minitest::Mock.new
    def resolver.timeouts=(val); end
    def resolver.close; end

    txt_resources = records.map do |record|
      resource = Minitest::Mock.new
      resource.expect :strings, [record]
      resource
    end

    resolver.expect :getresources, txt_resources, [String, Resolv::DNS::Resource::IN::TXT]
    resolver
  end

  def stub_plc_document(did, pds_url)
    doc = {
      "id" => did,
      "pds" => pds_url
    }
    stub_request(:get, "#{resolver.instance_variable_get(:@plc_directory)}/#{did}")
      .to_return(body: doc.to_json)
  end

  def stub_resource_server_metadata(pds_url, auth_server)
    stub_request(:get, "#{pds_url}/.well-known/oauth-protected-resource")
      .to_return(body: { authorization_servers: [auth_server] }.to_json)
  end
end
-----

test/atproto_auth/par/client_assertion_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"

describe AtprotoAuth::PAR::ClientAssertion do
  let(:client_id) { "test-client-id" }
  let(:audience) { "https://example.com/oauth/token" }
  let(:signing_key) do
    base_key = JOSE::JWK.generate_key([:ec, "P-256"])
    base_map = base_key.to_map

    key_map = {
      "kty" => base_map["kty"],
      "crv" => base_map["crv"],
      "x" => base_map["x"],
      "y" => base_map["y"],
      "d" => base_map["d"],
      "use" => "sig",
      "kid" => "test-key-id"
    }

    JOSE::JWK.from_map(key_map)
  end
  let(:client_assertion) { AtprotoAuth::PAR::ClientAssertion.new(client_id: client_id, signing_key: signing_key) }

  describe "#generate_jwt" do
    it "generates a valid JWT assertion" do
      lifetime = 300
      now = Time.now.to_i
      Time.stubs(:now).returns(Time.at(now)) # Stub Time.now for predictable timestamps

      jwt = client_assertion.generate_jwt(audience: audience, lifetime: lifetime)
      decoded, header = JWT.decode(jwt, signing_key.kty.key, true, { algorithm: "ES256" })

      # Verify claims
      _(decoded["iss"]).must_equal client_id
      _(decoded["sub"]).must_equal client_id
      _(decoded["aud"]).must_equal audience
      _(decoded["jti"]).wont_be_nil
      _(decoded["iat"]).must_equal now
      _(decoded["exp"]).must_equal now + lifetime

      # Verify header
      _(header["alg"]).must_equal "ES256"
      _(header["typ"]).must_equal "JWT"
      _(header["kid"]).must_equal "test-key-id"
    end

    it "raises an error if signing fails" do
      signing_key.stubs(:kty).returns(nil) # Simulate a signing key failure

      error = assert_raises(AtprotoAuth::PAR::ClientAssertion::Error) do
        client_assertion.generate_jwt(audience: audience)
      end

      _(error.message).must_match(/Failed to generate client assertion/)
    end

    it "defaults the lifetime to 5 minutes" do
      now = Time.now.to_i
      Time.stubs(:now).returns(Time.at(now))

      jwt = client_assertion.generate_jwt(audience: audience)
      decoded, _header = JWT.decode(jwt, signing_key.kty.key, true, { algorithm: "ES256" })

      _(decoded["exp"]).must_equal now + 300 # Default lifetime of 300 seconds
    end

    it "sets a unique jti for each assertion" do
      jti_values = []
      5.times do
        jwt = client_assertion.generate_jwt(audience: audience)
        decoded, = JWT.decode(jwt, signing_key.kty.key, true, { algorithm: "ES256" })
        jti_values << decoded["jti"]
      end

      _(jti_values.uniq.size).must_equal 5 # All jti values must be unique
    end

    it "includes the correct kid in the header" do
      jwt = client_assertion.generate_jwt(audience: audience)
      _decoded, header = JWT.decode(jwt, signing_key.kty.key, true, { algorithm: "ES256" })

      _(header["kid"]).must_equal "test-key-id"
    end
  end
end
-----

test/atproto_auth/par/client_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"

describe AtprotoAuth::PAR::Client do
  before do
    @endpoint = "https://auth.example.com/par"
    @dpop_client = mock("dpop_client")
    @nonce_manager = mock("nonce_manager")
    @dpop_client.stubs(:nonce_manager).returns(@nonce_manager)
    @client = AtprotoAuth::PAR::Client.new(endpoint: @endpoint, dpop_client: @dpop_client)
  end

  describe "#initialize" do
    it "raises an error if endpoint is not HTTPS" do
      assert_raises(AtprotoAuth::PAR::Error) do
        AtprotoAuth::PAR::Client.new(endpoint: "http://auth.example.com/par", dpop_client: @dpop_client)
      end
    end

    it "initializes correctly with a valid HTTPS endpoint" do
      assert_equal @endpoint, @client.endpoint
      assert_equal @dpop_client, @client.dpop_client
    end
  end

  describe "#submit" do
    before do
      @request = mock("request")
      @proof = "mocked_dpop_proof"
      @response = { status: 201, body: '{"request_uri":"mocked_uri","expires_in":3600}' }
      @server_origin = "https://auth.example.com"

      @request.stubs(:to_form).returns("client_id=mock_client_id&scope=mock_scope")
      @dpop_client.stubs(:generate_proof).returns(@proof)
      @nonce_manager.stubs(:get).returns("mocked_nonce")
      @http_client = mock("http_client")
      @http_client.stubs(:get)
      @http_client.stubs(:post).returns(@response)
      AtprotoAuth.configure do |configuration|
        configuration.http_client = @http_client
      end
    end

    it "submits the PAR request and returns a Response object on success" do
      response = @client.submit(@request)
      assert_instance_of AtprotoAuth::PAR::Response, response
      assert_equal "mocked_uri", response.request_uri
      assert_equal 3600, response.expires_in
    end

    it "retries the request with a nonce if the response indicates 'use_dpop_nonce'" do
      error_response = { status: 400, body: '{"error":"use_dpop_nonce"}', headers: { "DPoP-Nonce" => "new_nonce" } }
      @nonce_manager.expects(:update).with(nonce: "new_nonce", server_url: @server_origin)
      AtprotoAuth.configuration.http_client.stubs(:post).returns(error_response).then.returns(@response)

      response = @client.submit(@request)
      assert_instance_of AtprotoAuth::PAR::Response, response
    end

    it "raises an error if the response is invalid" do
      AtprotoAuth.configuration.http_client.stubs(:post).returns({ status: 400, body: '{"error":"invalid_request"}' })
      assert_raises(AtprotoAuth::PAR::Error) { @client.submit(@request) }
    end
  end

  describe "#authorization_url" do
    it "constructs a valid authorization URL" do
      authorize_endpoint = "https://auth.example.com/authorize"
      request_uri = "mocked_request_uri"
      client_id = "mocked_client_id"

      url = @client.authorization_url(authorize_endpoint: authorize_endpoint,
                                      request_uri: request_uri,
                                      client_id: client_id)
      expected_url = "https://auth.example.com/authorize?request_uri=mocked_request_uri&client_id=mocked_client_id"
      assert_equal expected_url, url
    end
  end
end
-----

test/atproto_auth/par/request_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"

describe AtprotoAuth::PAR::Request do
  let(:config) do
    AtprotoAuth::PAR::Request::Configuration.new.tap do |c|
      c.client_id = "client123"
      c.redirect_uri = "https://example.com/callback"
      c.code_challenge = "abc123"
      c.code_challenge_method = "S256"
      c.state = "xyz456"
      c.scope = "atproto read"
    end
  end

  describe ".build" do
    it "creates a new request instance" do
      request = AtprotoAuth::PAR::Request.build do |c|
        c.client_id = "client123"
        c.redirect_uri = "https://example.com/callback"
        c.code_challenge = "abc123"
        c.code_challenge_method = "S256"
        c.state = "xyz456"
        c.scope = "atproto read"
      end

      _(request).must_be_instance_of AtprotoAuth::PAR::Request
      _(request.client_id).must_equal "client123"
      _(request.redirect_uri).must_equal "https://example.com/callback"
    end
  end

  describe "#initialize" do
    it "initializes with valid configuration" do
      request = AtprotoAuth::PAR::Request.new(config)
      _(request.client_id).must_equal "client123"
      _(request.redirect_uri).must_equal "https://example.com/callback"
      _(request.code_challenge).must_equal "abc123"
      _(request.code_challenge_method).must_equal "S256"
      _(request.state).must_equal "xyz456"
      _(request.scope).must_equal "atproto read"
    end

    it "raises an error if a required parameter is missing" do
      config.client_id = nil
      assert_raises(AtprotoAuth::PAR::Error, "client_id is required") do
        AtprotoAuth::PAR::Request.new(config)
      end
    end

    it "raises an error if response_type is invalid" do
      request = AtprotoAuth::PAR::Request.new(config)
      request.instance_variable_set(:@response_type, "invalid")
      assert_raises(AtprotoAuth::PAR::Error, "response_type must be 'code'") do
        request.send(:validate_response_type!)
      end
    end

    it "raises an error if code_challenge_method is invalid" do
      config.code_challenge_method = "invalid"
      assert_raises(AtprotoAuth::PAR::Error, "code_challenge_method must be 'S256'") do
        AtprotoAuth::PAR::Request.new(config)
      end
    end

    it "raises an error if atproto scope is missing" do
      config.scope = "read"
      assert_raises(AtprotoAuth::PAR::Error, "atproto scope is required") do
        AtprotoAuth::PAR::Request.new(config)
      end
    end
  end

  describe "#to_form" do
    it "returns form-encoded parameters" do
      request = AtprotoAuth::PAR::Request.new(config)
      form = request.to_form
      _(form).must_include "client_id=client123"
      _(form).must_include "redirect_uri=https%3A%2F%2Fexample.com%2Fcallback"
      _(form).must_include "code_challenge=abc123"
      _(form).must_include "code_challenge_method=S256"
      _(form).must_include "state=xyz456"
      _(form).must_include "scope=atproto+read"
    end
  end
end
-----

test/atproto_auth/par/response_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"

describe AtprotoAuth::PAR::Response do
  describe "#initialize" do
    it "initializes with valid parameters" do
      response = AtprotoAuth::PAR::Response.new(request_uri: "https://example.com/request", expires_in: 3600)
      _(response.request_uri).must_equal "https://example.com/request"
      _(response.expires_in).must_equal 3600
    end

    it "raises an error if request_uri is missing" do
      assert_raises(AtprotoAuth::PAR::Error, "request_uri is required") do
        AtprotoAuth::PAR::Response.new(request_uri: nil, expires_in: 3600)
      end
    end

    it "raises an error if request_uri is empty" do
      assert_raises(AtprotoAuth::PAR::Error, "request_uri is required") do
        AtprotoAuth::PAR::Response.new(request_uri: "", expires_in: 3600)
      end
    end

    it "raises an error if expires_in is not positive" do
      assert_raises(AtprotoAuth::PAR::Error, "expires_in must be positive") do
        AtprotoAuth::PAR::Response.new(request_uri: "https://example.com/request", expires_in: 0)
      end
    end
  end
end
-----

test/atproto_auth/pkce_test.rb:
# frozen_string_literal: true

require_relative "../test_helper"

describe AtprotoAuth::PKCE do
  let(:valid_verifier) { "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~" }
  let(:short_verifier) { "short" }
  let(:long_verifier) { "a" * 129 }
  let(:invalid_verifier) { "invalid_verifier!" }
  let(:challenge) { AtprotoAuth::PKCE.generate_challenge(valid_verifier) }

  describe ".generate_verifier" do
    it "generates a valid code verifier of default length" do
      verifier = AtprotoAuth::PKCE.generate_verifier
      _(verifier.length).must_equal AtprotoAuth::PKCE::MAX_VERIFIER_LENGTH
      _(verifier).must_match AtprotoAuth::PKCE::ALLOWED_VERIFIER_CHARS
    end

    it "generates a valid code verifier of specified length" do
      length = 50
      verifier = AtprotoAuth::PKCE.generate_verifier(length)
      _(verifier.length).must_equal length
      _(verifier).must_match AtprotoAuth::PKCE::ALLOWED_VERIFIER_CHARS
    end

    it "raises an error for a length below the minimum" do
      assert_raises(AtprotoAuth::PKCE::Error) do
        AtprotoAuth::PKCE.generate_verifier(AtprotoAuth::PKCE::MIN_VERIFIER_LENGTH - 1)
      end
    end

    it "raises an error for a length above the maximum" do
      assert_raises(AtprotoAuth::PKCE::Error) do
        AtprotoAuth::PKCE.generate_verifier(AtprotoAuth::PKCE::MAX_VERIFIER_LENGTH + 1)
      end
    end
  end

  describe ".generate_challenge" do
    it "generates a valid challenge for a given verifier" do
      challenge = AtprotoAuth::PKCE.generate_challenge(valid_verifier)
      _(challenge).must_match(/^[A-Za-z0-9\-_]+$/)
    end

    it "raises an error for a nil verifier" do
      assert_raises(AtprotoAuth::PKCE::Error) do
        AtprotoAuth::PKCE.generate_challenge(nil)
      end
    end

    it "raises an error for an empty verifier" do
      assert_raises(AtprotoAuth::PKCE::Error) do
        AtprotoAuth::PKCE.generate_challenge("")
      end
    end

    it "raises an error for a verifier below the minimum length" do
      assert_raises(AtprotoAuth::PKCE::Error) do
        AtprotoAuth::PKCE.generate_challenge(short_verifier)
      end
    end

    it "raises an error for a verifier above the maximum length" do
      assert_raises(AtprotoAuth::PKCE::Error) do
        AtprotoAuth::PKCE.generate_challenge(long_verifier)
      end
    end

    it "raises an error for a verifier with invalid characters" do
      assert_raises(AtprotoAuth::PKCE::Error) do
        AtprotoAuth::PKCE.generate_challenge(invalid_verifier)
      end
    end
  end

  describe ".verify" do
    it "returns true for a valid verifier and matching challenge" do
      result = AtprotoAuth::PKCE.verify(challenge, valid_verifier)
      _(result).must_equal true
    end

    it "returns false for a valid verifier and non-matching challenge" do
      non_matching_challenge = AtprotoAuth::PKCE.generate_challenge("different_verifier_different_verifier_12345")
      result = AtprotoAuth::PKCE.verify(non_matching_challenge, valid_verifier)
      _(result).must_equal false
    end

    it "raises an error for a nil challenge" do
      assert_raises(AtprotoAuth::PKCE::Error) do
        AtprotoAuth::PKCE.verify(nil, valid_verifier)
      end
    end

    it "raises an error for a nil verifier" do
      assert_raises(AtprotoAuth::PKCE::Error) do
        AtprotoAuth::PKCE.verify(challenge, nil)
      end
    end

    it "raises an error for a verifier with invalid characters" do
      assert_raises(AtprotoAuth::PKCE::Error) do
        AtprotoAuth::PKCE.verify(challenge, invalid_verifier)
      end
    end
  end
end
-----

test/atproto_auth/serialization/base_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"

class TestSerializer < AtprotoAuth::Serialization::Base
  def type_identifier
    "Test"
  end

  private

  def serialize_data(obj)
    { "value" => obj }
  end

  def deserialize_data(data)
    data["value"]
  end

  def validate_object!(obj)
    raise AtprotoAuth::Serialization::ValidationError unless obj.is_a?(String)
  end
end

describe AtprotoAuth::Serialization::Base do
  let(:serializer) { TestSerializer.new }
  let(:sample_data) { "test data" }

  describe "#serialize" do
    it "creates valid serialized format" do
      result = JSON.parse(serializer.serialize(sample_data))

      assert_equal AtprotoAuth::Serialization::Base::CURRENT_VERSION, result["version"]
      assert_equal "Test", result["type"]
      assert result["created_at"]
      assert result["updated_at"]
      assert result["data"]
    end

    it "encrypts sensitive fields" do
      sensitive_data = { "access_token" => "secret" }
      serializer.stubs(:serialize_data).returns(sensitive_data)

      result = JSON.parse(serializer.serialize("test"))
      encrypted = result["data"]["access_token"]

      assert encrypted.key?("version")
      assert encrypted.key?("iv")
      assert encrypted.key?("data")
      assert encrypted.key?("tag")
    end

    it "raises ValidationError for invalid objects" do
      assert_raises(AtprotoAuth::Serialization::ValidationError) do
        serializer.serialize(123)
      end
    end
  end

  describe "#deserialize" do
    it "correctly deserializes and decrypts data" do
      serialized = serializer.serialize(sample_data) # { "value" => obj }
      deserialized = serializer.deserialize(serialized) # data["value"]

      assert_equal sample_data, deserialized
    end

    it "raises Error for invalid JSON" do
      assert_raises(AtprotoAuth::Serialization::Error) do
        serializer.deserialize("invalid json")
      end
    end

    it "raises TypeMismatchError for wrong type" do
      serialized = TestSerializer.new.serialize(sample_data)
      data = JSON.parse(serialized)
      data["type"] = "Wrong"

      assert_raises(AtprotoAuth::Serialization::TypeMismatchError) do
        serializer.deserialize(JSON.generate(data))
      end
    end

    it "raises VersionError for unsupported version" do
      serialized = TestSerializer.new.serialize(sample_data)
      data = JSON.parse(serialized)
      data["version"] = 999

      assert_raises(AtprotoAuth::Serialization::VersionError) do
        serializer.deserialize(JSON.generate(data))
      end
    end
  end
end
-----

test/atproto_auth/serialization/dpop_key_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"

describe AtprotoAuth::Serialization::DPoPKey do
  let(:key_manager) { AtprotoAuth::DPoP::KeyManager.new }
  let(:serializer) { AtprotoAuth::Serialization::DPoPKey.new }

  it "roundtrips a DPoP key manager object" do
    serialized = serializer.serialize(key_manager)
    deserialized = serializer.deserialize(serialized)

    # Compare public key components
    original_jwk = key_manager.public_jwk
    deserialized_jwk = deserialized.public_jwk

    assert_equal original_jwk["kty"], deserialized_jwk["kty"]
    assert_equal original_jwk["crv"], deserialized_jwk["crv"]
    assert_equal original_jwk["x"], deserialized_jwk["x"]
    assert_equal original_jwk["y"], deserialized_jwk["y"]
  end

  it "encrypts private key material" do
    serialized = JSON.parse(serializer.serialize(key_manager))
    jwk = serialized["data"]

    assert_encrypted jwk["d"] if jwk["d"] # Private key component
  end

  it "validates object type" do
    assert_raises(AtprotoAuth::Serialization::ValidationError) do
      serializer.serialize(Object.new)
    end
  end
end
-----

test/atproto_auth/serialization/session_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"

describe AtprotoAuth::Serialization::Session do
  let(:client_id) { "test_client" }
  let(:scope) { "test_scope" }
  let(:session) do
    AtprotoAuth::State::Session.new(
      client_id: client_id,
      scope: scope
    )
  end
  let(:serializer) { AtprotoAuth::Serialization::Session.new }

  it "roundtrips a session object" do
    serialized = serializer.serialize(session)
    deserialized = serializer.deserialize(serialized)

    assert_equal session.session_id, deserialized.session_id
    assert_equal session.state_token, deserialized.state_token
    assert_equal session.client_id, deserialized.client_id
    assert_equal session.scope, deserialized.scope
    assert_equal session.pkce_verifier, deserialized.pkce_verifier
    assert_equal session.pkce_challenge, deserialized.pkce_challenge
  end

  it "encrypts sensitive session data" do
    serialized = JSON.parse(serializer.serialize(session))

    assert_encrypted serialized.dig("data", "pkce_verifier")
    assert_encrypted serialized.dig("data", "tokens", "access_token") if session.tokens
  end

  it "validates object type" do
    assert_raises(AtprotoAuth::Serialization::ValidationError) do
      serializer.serialize(Object.new)
    end
  end
end
-----

test/atproto_auth/serialization/stored_nonce_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"

describe AtprotoAuth::Serialization::StoredNonce do
  let(:stored_nonce) do
    AtprotoAuth::DPoP::NonceManager::StoredNonce.new(
      "test_nonce",
      "https://example.com"
    )
  end
  let(:serializer) { AtprotoAuth::Serialization::StoredNonce.new }

  it "roundtrips a stored nonce object" do
    serialized = serializer.serialize(stored_nonce)
    deserialized = serializer.deserialize(serialized)

    assert_equal stored_nonce.value, deserialized.value
    assert_equal stored_nonce.server_url, deserialized.server_url
    assert_equal stored_nonce.timestamp.to_i, deserialized.timestamp.to_i
  end

  it "validates object type" do
    assert_raises(AtprotoAuth::Serialization::ValidationError) do
      serializer.serialize(Object.new)
    end
  end
end
-----

test/atproto_auth/serialization/token_set_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"

describe AtprotoAuth::Serialization::TokenSet do
  let(:token_set) do
    AtprotoAuth::State::TokenSet.new(
      access_token: "test_access_token",
      refresh_token: "test_refresh_token",
      token_type: "DPoP",
      expires_in: 3600,
      scope: "test_scope",
      sub: "test_sub"
    )
  end
  let(:serializer) { AtprotoAuth::Serialization::TokenSet.new }

  it "roundtrips a token set object" do
    serialized = serializer.serialize(token_set)
    deserialized = serializer.deserialize(serialized)

    assert_equal token_set.access_token, deserialized.access_token
    assert_equal token_set.refresh_token, deserialized.refresh_token
    assert_equal token_set.token_type, deserialized.token_type
    assert_equal token_set.scope, deserialized.scope
    assert_equal token_set.sub, deserialized.sub
  end

  it "encrypts sensitive token data" do
    serialized = JSON.parse(serializer.serialize(token_set))

    assert_encrypted serialized.dig("data", "access_token")
    assert_encrypted serialized.dig("data", "refresh_token")
  end

  it "validates object type" do
    assert_raises(AtprotoAuth::Serialization::ValidationError) do
      serializer.serialize(Object.new)
    end
  end
end
-----

test/atproto_auth/server_metadata/authorization_server_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"

describe AtprotoAuth::ServerMetadata::AuthorizationServer do
  let(:valid_metadata) do
    {
      "issuer" => "https://auth.example.com",
      "authorization_endpoint" => "https://auth.example.com/authorize",
      "token_endpoint" => "https://auth.example.com/token",
      "response_types_supported" => ["code"],
      "grant_types_supported" => %w[authorization_code refresh_token],
      "code_challenge_methods_supported" => ["S256"],
      "token_endpoint_auth_methods_supported" => %w[private_key_jwt none],
      "token_endpoint_auth_signing_alg_values_supported" => ["ES256"],
      "scopes_supported" => %w[atproto email profile],
      "dpop_signing_alg_values_supported" => ["ES256"],
      "pushed_authorization_request_endpoint" => "https://auth.example.com/par",
      "authorization_response_iss_parameter_supported" => true,
      "require_pushed_authorization_requests" => true,
      "client_id_metadata_document_supported" => true
    }
  end

  let(:invalid_metadata_missing_field) { valid_metadata.except("issuer") }
  let(:invalid_metadata_bad_url) { valid_metadata.merge("issuer" => "http://auth.example.com") }
  let(:issuer_url) { "https://auth.example.com" }
  let(:mock_response) { { body: valid_metadata.to_json } }

  describe "#initialize" do
    it "initializes successfully with valid metadata" do
      server = AtprotoAuth::ServerMetadata::AuthorizationServer.new(valid_metadata)
      _(server.issuer).must_equal valid_metadata["issuer"]
      _(server.authorization_endpoint).must_equal valid_metadata["authorization_endpoint"]
    end

    it "raises an error if a required field is missing" do
      assert_raises(AtprotoAuth::InvalidAuthorizationServer) do
        AtprotoAuth::ServerMetadata::AuthorizationServer.new(invalid_metadata_missing_field)
      end
    end

    it "raises an error for an invalid HTTPS URL" do
      assert_raises(AtprotoAuth::InvalidAuthorizationServer) do
        AtprotoAuth::ServerMetadata::AuthorizationServer.new(invalid_metadata_bad_url)
      end
    end
  end

  describe ".from_issuer" do
    before do
      AtprotoAuth.configuration.stubs(:http_client).returns(mock_http_client = mock)
      mock_http_client.stubs(:get).with("#{issuer_url}/.well-known/oauth-authorization-server").returns(mock_response)
    end

    it "fetches and parses metadata successfully" do
      server = AtprotoAuth::ServerMetadata::AuthorizationServer.from_issuer(issuer_url)
      _(server.issuer).must_equal valid_metadata["issuer"]
    end

    it "raises an error if fetching metadata fails" do
      AtprotoAuth.configuration.http_client.stubs(:get).raises(AtprotoAuth::HttpClient::HttpError.new("Network error",
                                                                                                      {}))
      assert_raises(AtprotoAuth::InvalidAuthorizationServer) do
        AtprotoAuth::ServerMetadata::AuthorizationServer.from_issuer(issuer_url)
      end
    end

    it "raises an error if the metadata JSON is invalid" do
      AtprotoAuth.configuration.http_client.stubs(:get).returns(body: "not-json")
      assert_raises(AtprotoAuth::InvalidAuthorizationServer) do
        AtprotoAuth::ServerMetadata::AuthorizationServer.from_issuer(issuer_url)
      end
    end

    it "raises an error if the issuer in metadata does not match the request issuer" do
      invalid_metadata = valid_metadata.merge("issuer" => "https://other.example.com")
      AtprotoAuth.configuration.http_client.stubs(:get).returns(body: invalid_metadata.to_json)

      assert_raises(AtprotoAuth::InvalidAuthorizationServer) do
        AtprotoAuth::ServerMetadata::AuthorizationServer.from_issuer(issuer_url)
      end
    end
  end

  describe "validation methods" do
    it "validates required fields" do
      server = AtprotoAuth::ServerMetadata::AuthorizationServer.new(valid_metadata)
      assert_raises(AtprotoAuth::InvalidAuthorizationServer) do
        server.send(:validate_boolean_field!, valid_metadata, "nonexistent_field", true)
      end
    end

    it "validates response types" do
      invalid_response_types = valid_metadata.merge("response_types_supported" => [])
      assert_raises(AtprotoAuth::InvalidAuthorizationServer) do
        AtprotoAuth::ServerMetadata::AuthorizationServer.new(invalid_response_types)
      end
    end

    it "validates grant types" do
      invalid_grant_types = valid_metadata.merge("grant_types_supported" => ["authorization_code"])
      assert_raises(AtprotoAuth::InvalidAuthorizationServer) do
        AtprotoAuth::ServerMetadata::AuthorizationServer.new(invalid_grant_types)
      end
    end

    it "validates token endpoint auth methods" do
      invalid_auth_methods = valid_metadata.merge("token_endpoint_auth_methods_supported" => ["none"])
      assert_raises(AtprotoAuth::InvalidAuthorizationServer) do
        AtprotoAuth::ServerMetadata::AuthorizationServer.new(invalid_auth_methods)
      end
    end
  end
end
-----

test/atproto_auth/server_metadata/origin_url_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"

describe AtprotoAuth::ServerMetadata::OriginUrl do
  let(:valid_url) { "https://example.com" }
  let(:valid_url_with_port) { "https://example.com:8443" }
  let(:url_with_http) { "http://example.com" }
  let(:url_with_path) { "https://example.com/path" }
  let(:url_with_query) { "https://example.com?query=1" }
  let(:url_with_fragment) { "https://example.com#fragment" }
  let(:url_with_userinfo) { "https://user:pass@example.com" }
  let(:url_with_default_port) { "https://example.com:443" }
  let(:malformed_url) { "not a url" }

  describe "#valid?" do
    it "returns true for a valid origin URL" do
      origin_url = AtprotoAuth::ServerMetadata::OriginUrl.new(valid_url)
      _(origin_url.valid?).must_equal true
    end

    it "returns true for a valid origin URL with a non-default port" do
      origin_url = AtprotoAuth::ServerMetadata::OriginUrl.new(valid_url_with_port)
      _(origin_url.valid?).must_equal true
    end

    it "returns false for a URL using HTTP scheme" do
      origin_url = AtprotoAuth::ServerMetadata::OriginUrl.new(url_with_http)
      _(origin_url.valid?).must_equal false
    end

    it "returns false for a URL with a non-root path" do
      origin_url = AtprotoAuth::ServerMetadata::OriginUrl.new(url_with_path)
      _(origin_url.valid?).must_equal false
    end

    it "returns false for a URL with a query string" do
      origin_url = AtprotoAuth::ServerMetadata::OriginUrl.new(url_with_query)
      _(origin_url.valid?).must_equal false
    end

    it "returns false for a URL with a fragment" do
      origin_url = AtprotoAuth::ServerMetadata::OriginUrl.new(url_with_fragment)
      _(origin_url.valid?).must_equal false
    end

    it "returns false for a URL with userinfo (credentials)" do
      origin_url = AtprotoAuth::ServerMetadata::OriginUrl.new(url_with_userinfo)
      _(origin_url.valid?).must_equal false
    end

    it "returns false for a URL with the default HTTPS port (443)" do
      origin_url = AtprotoAuth::ServerMetadata::OriginUrl.new(url_with_default_port)
      _(origin_url.valid?).must_equal false
    end

    it "raises an error for a malformed URL" do
      assert_raises(URI::InvalidURIError) do
        AtprotoAuth::ServerMetadata::OriginUrl.new(malformed_url).valid?
      end
    end
  end
end
-----

test/atproto_auth/server_metadata/resource_server_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"

describe AtprotoAuth::ServerMetadata::ResourceServer do
  let(:valid_metadata) { { "authorization_servers" => ["https://auth.example.com"] } }
  let(:invalid_metadata_missing_servers) { {} }
  let(:invalid_metadata_multiple_servers) { { "authorization_servers" => ["https://auth1.example.com", "https://auth2.example.com"] } }
  let(:invalid_metadata_bad_url) { { "authorization_servers" => ["http://auth.example.com"] } }
  let(:valid_url) { "https://example.com" }
  let(:mock_response) { { body: valid_metadata.to_json } }

  describe "#initialize" do
    it "initializes successfully with valid metadata" do
      server = AtprotoAuth::ServerMetadata::ResourceServer.new(valid_metadata)
      _(server.authorization_servers).must_equal valid_metadata["authorization_servers"]
    end

    it "raises an error if authorization_servers is missing" do
      assert_raises(AtprotoAuth::InvalidAuthorizationServer) do
        AtprotoAuth::ServerMetadata::ResourceServer.new(invalid_metadata_missing_servers)
      end
    end

    it "raises an error if there are multiple authorization_servers" do
      assert_raises(AtprotoAuth::InvalidAuthorizationServer) do
        AtprotoAuth::ServerMetadata::ResourceServer.new(invalid_metadata_multiple_servers)
      end
    end

    it "raises an error for invalid authorization server URL format" do
      assert_raises(AtprotoAuth::InvalidAuthorizationServer) do
        AtprotoAuth::ServerMetadata::ResourceServer.new(invalid_metadata_bad_url)
      end
    end
  end

  describe ".from_url" do
    before do
      AtprotoAuth.configuration.stubs(:http_client).returns(mock_http_client = mock)
      mock_http_client.stubs(:get).with("#{valid_url}/.well-known/oauth-protected-resource").returns(mock_response)
    end

    it "fetches and parses metadata successfully" do
      server = AtprotoAuth::ServerMetadata::ResourceServer.from_url(valid_url)
      _(server.authorization_servers).must_equal valid_metadata["authorization_servers"]
    end

    it "raises an error if fetching metadata fails" do
      AtprotoAuth.configuration.http_client.stubs(:get).raises(AtprotoAuth::HttpClient::HttpError.new("Network error",
                                                                                                      {}))
      assert_raises(AtprotoAuth::InvalidAuthorizationServer) do
        AtprotoAuth::ServerMetadata::ResourceServer.from_url(valid_url)
      end
    end

    it "raises an error if the metadata JSON is invalid" do
      AtprotoAuth.configuration.http_client.stubs(:get).returns(body: "not-json")
      assert_raises(AtprotoAuth::InvalidAuthorizationServer) do
        AtprotoAuth::ServerMetadata::ResourceServer.from_url(valid_url)
      end
    end
  end
end
-----

test/atproto_auth/state/session_manager_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"

describe AtprotoAuth::State::SessionManager do
  let(:client_id) { "test_client_id" }
  let(:scope) { "read write" }
  let(:auth_server) do
    AtprotoAuth::ServerMetadata::AuthorizationServer.new(
      "issuer" => "https://example.com",
      "token_endpoint" => "https://example.com/token",
      "authorization_endpoint" => "https://example.com/auth",
      "response_types_supported" => "code",
      "grant_types_supported" => %w[authorization_code refresh_token],
      "code_challenge_methods_supported" => "S256",
      "token_endpoint_auth_methods_supported" => %w[private_key_jwt none],
      "token_endpoint_auth_signing_alg_values_supported" => %w[ES256],
      "scopes_supported" => %w[atproto],
      "dpop_signing_alg_values_supported" => %w[ES256],
      "pushed_authorization_request_endpoint" => "https://example.com/pushed_auth",
      "authorization_response_iss_parameter_supported" => true,
      "require_pushed_authorization_requests" => true,
      "client_id_metadata_document_supported" => true
    )
  end
  let(:did) { "did:example:1234" }
  let(:session_manager) { AtprotoAuth::State::SessionManager.new }
  let(:storage) { AtprotoAuth::Storage::Memory.new }

  before do
    AtprotoAuth.stubs(:storage).returns(storage)
    auth_server.stubs(:as_json).returns({ some: value })
  end

  describe "#create_session" do
    it "creates and stores a new session" do
      session = session_manager.create_session(client_id: client_id, scope: scope, auth_server: auth_server, did: did)

      # Verify session was stored
      session_key = AtprotoAuth::Storage::KeyBuilder.session_key(session.session_id)
      stored = storage.get(session_key)
      assert stored, "Session was not stored"

      # Verify state mapping was stored
      state_key = AtprotoAuth::Storage::KeyBuilder.state_key(session.state_token)
      state_mapping = storage.get(state_key)
      assert_equal session.session_id, state_mapping
    end
  end

  describe "#update_session" do
    let(:client_id) { "test_client_id" }
    let(:scope) { "read write" }
    let(:session) do
      session_manager.create_session(client_id: client_id, scope: scope)
    end

    it "updates an existing session" do
      # Update session with new data
      session.did = "did:test:123"
      updated = session_manager.update_session(session)

      # Verify session was stored correctly
      retrieved = session_manager.get_session(session.session_id)
      _(retrieved.did).must_equal "did:test:123"
      _(retrieved.session_id).must_equal session.session_id
      _(updated).must_equal session
    end

    it "maintains state token mapping after update" do
      updated = session_manager.update_session(session)
      retrieved = session_manager.get_session_by_state(updated.state_token)

      _(retrieved).wont_be_nil
      _(retrieved.session_id).must_equal session.session_id
    end

    it "handles storage errors gracefully" do
      failing_storage = Class.new(AtprotoAuth::Storage::Interface) do
        def set(*)
          raise AtprotoAuth::Storage::StorageError, "Storage failure"
        end

        def with_lock(*)
          yield if block_given?
        end
      end.new

      AtprotoAuth.stubs(:storage).returns(failing_storage)

      assert_raises(AtprotoAuth::Storage::StorageError) do
        session_manager.update_session(session)
      end
    end

    it "updates both session and state mapping atomically" do
      original_state = session.state_token

      # Verify both session and state mapping are updated
      updates = []
      storage.define_singleton_method(:set) do |key, value|
        updates << key
        super(key, value)
      end

      session_manager.update_session(session)

      session_key = AtprotoAuth::Storage::KeyBuilder.session_key(session.session_id)
      state_key = AtprotoAuth::Storage::KeyBuilder.state_key(original_state)

      _(updates).must_include session_key
      _(updates).must_include state_key
    end
  end

  describe "#get_session" do
    it "retrieves an existing session by ID" do
      original = session_manager.create_session(client_id: client_id, scope: scope, auth_server: auth_server, did: did)
      retrieved = session_manager.get_session(original.session_id)

      assert_equal original.session_id, retrieved.session_id
      assert_equal original.client_id, retrieved.client_id
      assert_equal original.scope, retrieved.scope
    end

    it "returns nil for a non-existent session ID" do
      assert_nil session_manager.get_session("non_existent_session_id")
    end

    it "returns nil if deserialization fails" do
      session = session_manager.create_session(client_id: client_id, scope: scope)
      session_key = AtprotoAuth::Storage::KeyBuilder.session_key(session.session_id)

      # Corrupt the stored data
      storage.set(session_key, "invalid json")

      assert_nil session_manager.get_session(session.session_id)
    end

    it "returns nil for expired non-renewable sessions" do
      session = session_manager.create_session(client_id: client_id, scope: scope)

      # Add expired tokens
      tokens = AtprotoAuth::State::TokenSet.new(
        access_token: "expired_token",
        token_type: "DPoP",
        expires_in: 1,
        scope: scope,
        sub: did
      )
      tokens.instance_variable_set(:@expires_at, Time.now - 10)
      session.tokens = tokens

      # Re-store the session with expired tokens
      session_key = AtprotoAuth::Storage::KeyBuilder.session_key(session.session_id)
      serializer = AtprotoAuth::Serialization::Session.new
      storage.set(session_key, serializer.serialize(session))

      assert_nil session_manager.get_session(session.session_id)
    end
  end

  describe "#get_session_by_state" do
    it "retrieves a session by a valid state token" do
      original = session_manager.create_session(client_id: client_id, scope: scope, auth_server: auth_server, did: did)
      retrieved = session_manager.get_session_by_state(original.state_token)
      assert_equal original.session_id, retrieved.session_id
    end

    it "returns nil for an invalid state token" do
      session_manager.create_session(client_id: client_id, scope: scope)
      assert_nil session_manager.get_session_by_state("invalid_state_token")
    end

    it "returns nil for nil state" do
      assert_nil session_manager.get_session_by_state(nil)
    end
  end

  describe "#remove_session" do
    it "removes a session and its state mapping" do
      session = session_manager.create_session(client_id: client_id, scope: scope)
      session_key = AtprotoAuth::Storage::KeyBuilder.session_key(session.session_id)
      state_key = AtprotoAuth::Storage::KeyBuilder.state_key(session.state_token)

      session_manager.remove_session(session.session_id)

      refute storage.exists?(session_key), "Session was not removed"
      refute storage.exists?(state_key), "State mapping was not removed"
    end

    it "handles removal of non-existent session" do
      assert_nil session_manager.remove_session("non_existent_session_id")
    end
  end

  describe "storage integration" do
    it "handles storage errors gracefully" do
      # Create a failing storage implementation
      failing_storage = Class.new(AtprotoAuth::Storage::Interface) do
        def set(*)
          raise AtprotoAuth::Storage::StorageError, "Storage failure"
        end

        def get(*)
          raise AtprotoAuth::Storage::StorageError, "Storage failure"
        end

        def delete(*)
          raise AtprotoAuth::Storage::StorageError, "Storage failure"
        end

        def exists?(*)
          raise AtprotoAuth::Storage::StorageError, "Storage failure"
        end

        def multi_get(*)
          raise AtprotoAuth::Storage::StorageError, "Storage failure"
        end

        def multi_set(*)
          raise AtprotoAuth::Storage::StorageError, "Storage failure"
        end

        def acquire_lock(*)
          false
        end

        def release_lock(*)
          true
        end

        def with_lock(*)
          yield if block_given?
        end
      end.new

      AtprotoAuth.stubs(:storage).returns(failing_storage)

      # Test error handling
      assert_raises(AtprotoAuth::Storage::StorageError) do
        session_manager.create_session(client_id: client_id, scope: scope)
      end

      assert_nil session_manager.get_session("any_id")
      assert_nil session_manager.get_session_by_state("any_state")
    end
  end
end
-----

test/atproto_auth/state/session_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"

describe AtprotoAuth::State::Session do
  let(:client_id) { "test_client_id" }
  let(:scope) { "read write" }
  let(:auth_server) { nil }
  let(:did) { "did:example:1234" }
  let(:tokens) do
    AtprotoAuth::State::TokenSet.new(
      access_token: "valid_access_token",
      token_type: "DPoP",
      expires_in: 3600,
      refresh_token: "valid_refresh_token",
      scope: scope,
      sub: did
    )
  end
  let(:session) do
    AtprotoAuth::State::Session.new(client_id: client_id, scope: scope, auth_server: auth_server, did: did)
  end

  describe "#initialize" do
    let(:auth_server) { mock("AuthorizationServer") }

    it "initializes with valid parameters" do
      _(session.session_id).wont_be_nil
      _(session.state_token).wont_be_nil
      _(session.client_id).must_equal client_id
      _(session.scope).must_equal scope
      _(session.auth_server).must_equal auth_server
      _(session.did).must_equal did
      _(session.pkce_verifier).wont_be_nil
      _(session.pkce_challenge).wont_be_nil
      _(session.tokens).must_be_nil
    end

    it "generates unique session_id and state_token" do
      another_session = AtprotoAuth::State::Session.new(client_id: client_id, scope: scope)
      _(session.session_id).wont_equal another_session.session_id
      _(session.state_token).wont_equal another_session.state_token
    end
  end

  describe "#authorization_server=" do
    it "sets the authorization server if not already set" do
      new_server = mock("AuthorizationServer")
      session.authorization_server = new_server
      _(session.auth_server).must_equal new_server
    end

    describe "when an existing authorization server is set" do
      let(:auth_server) { mock("AuthorizationServer", issuer: "https://auth.example.com") }

      it "raises an error if setting a different authorization server" do
        new_server = mock("AuthorizationServer", issuer: "https://auth2.example.com")
        assert_raises(AtprotoAuth::State::SessionError) do
          session.authorization_server = new_server
        end
      end
    end
  end

  describe "#did=" do
    describe "when the DID is not already has a DID" do
      let(:did) { nil }

      it "sets the DID" do
        new_did = "did:example:5678"
        session.did = new_did
        _(session.did).must_equal new_did
      end
    end

    it "raises an error if setting a different DID" do
      new_did = "did:example:5678"
      assert_raises(AtprotoAuth::State::SessionError) do
        session.did = new_did
      end
    end
  end

  describe "#tokens=" do
    it "sets the tokens if they match the session DID" do
      session.tokens = tokens
      _(session.tokens).must_equal tokens
    end

    it "sets the DID if it was not previously set" do
      session_without_did = AtprotoAuth::State::Session.new(client_id: client_id, scope: scope)
      session_without_did.tokens = tokens
      _(session_without_did.did).must_equal tokens.sub
    end

    it "raises an error if the tokens' subject does not match the session DID" do
      mismatched_tokens = AtprotoAuth::State::TokenSet.new(
        access_token: "valid_access_token",
        token_type: "DPoP",
        expires_in: 3600,
        scope: scope,
        sub: "did:example:5678"
      )
      assert_raises(AtprotoAuth::State::SessionError) do
        session.tokens = mismatched_tokens
      end
    end
  end

  describe "#authorized?" do
    it "returns true if tokens are set and not expired" do
      session.tokens = tokens
      _(session.authorized?).must_equal true
    end

    it "returns false if tokens are nil" do
      _(session.authorized?).must_equal false
    end

    it "returns false if tokens are expired" do
      expired_tokens = AtprotoAuth::State::TokenSet.new(
        access_token: "expired_access_token",
        token_type: "DPoP",
        expires_in: 1,
        scope: scope,
        sub: did
      )
      expired_tokens.instance_variable_set(:@expires_at, Time.now - 10)
      session.tokens = expired_tokens
      _(session.authorized?).must_equal false
    end
  end

  describe "#renewable?" do
    it "returns true if tokens are set and renewable" do
      session.tokens = tokens
      _(session.renewable?).must_equal true
    end

    it "returns false if tokens are nil" do
      _(session.renewable?).must_equal false
    end

    it "returns false if tokens are not renewable" do
      non_renewable_tokens = AtprotoAuth::State::TokenSet.new(
        access_token: "valid_access_token",
        token_type: "DPoP",
        expires_in: 3600,
        scope: scope,
        sub: did
      )
      session.tokens = non_renewable_tokens
      _(session.renewable?).must_equal false
    end
  end

  describe "#validate_state" do
    it "returns true for a matching state token" do
      _(session.validate_state(session.state_token)).must_equal true
    end

    it "returns false for a non-matching state token" do
      _(session.validate_state("invalid_state")).must_equal false
    end

    it "returns false for a nil state token" do
      _(session.validate_state(nil)).must_equal false
    end
  end
end
-----

test/atproto_auth/state/token_set_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"

describe AtprotoAuth::State::TokenSet do
  let(:access_token) { "valid_access_token" }
  let(:refresh_token) { "valid_refresh_token" }
  let(:token_type) { "DPoP" }
  let(:expires_in) { 3600 }
  let(:scope) { "read write" }
  let(:sub) { "did:example:1234" }
  let(:token_set) do
    AtprotoAuth::State::TokenSet.new(
      access_token: access_token,
      token_type: token_type,
      expires_in: expires_in,
      refresh_token: refresh_token,
      scope: scope,
      sub: sub
    )
  end

  describe "#initialize" do
    it "initializes with valid parameters" do
      _(token_set.access_token).must_equal access_token
      _(token_set.refresh_token).must_equal refresh_token
      _(token_set.token_type).must_equal token_type
      _(token_set.scope).must_equal scope
      _(token_set.sub).must_equal sub
      _(token_set.expires_at).must_be_instance_of Time
      _(token_set.expires_at).must_be :>, Time.now
    end

    it "raises an error if token_type is not 'DPoP'" do
      assert_raises(ArgumentError, "token_type must be DPoP") do
        AtprotoAuth::State::TokenSet.new(
          access_token: access_token,
          token_type: "Bearer",
          expires_in: expires_in,
          refresh_token: refresh_token,
          scope: scope,
          sub: sub
        )
      end
    end

    it "raises an error if required parameters are missing" do
      assert_raises(ArgumentError, "access_token is required") do
        AtprotoAuth::State::TokenSet.new(
          access_token: nil,
          token_type: token_type,
          expires_in: expires_in,
          refresh_token: refresh_token,
          scope: scope,
          sub: sub
        )
      end

      assert_raises(ArgumentError, "scope is required") do
        AtprotoAuth::State::TokenSet.new(
          access_token: access_token,
          token_type: token_type,
          expires_in: expires_in,
          refresh_token: refresh_token,
          scope: nil,
          sub: sub
        )
      end

      assert_raises(ArgumentError, "sub is required") do
        AtprotoAuth::State::TokenSet.new(
          access_token: access_token,
          token_type: token_type,
          expires_in: expires_in,
          refresh_token: refresh_token,
          scope: scope,
          sub: nil
        )
      end
    end

    it "raises an error if expires_in is not a positive integer" do
      assert_raises(ArgumentError, "expires_in must be positive integer") do
        AtprotoAuth::State::TokenSet.new(
          access_token: access_token,
          token_type: token_type,
          expires_in: -1,
          refresh_token: refresh_token,
          scope: scope,
          sub: sub
        )
      end
    end
  end

  describe "#renewable?" do
    it "returns true if refresh_token is present" do
      _(token_set.renewable?).must_equal true
    end

    it "returns false if refresh_token is nil" do
      token_set_without_refresh = AtprotoAuth::State::TokenSet.new(
        access_token: access_token,
        token_type: token_type,
        expires_in: expires_in,
        scope: scope,
        sub: sub
      )
      _(token_set_without_refresh.renewable?).must_equal false
    end
  end

  describe "#expired?" do
    it "returns false if token has not expired" do
      _(token_set.expired?).must_equal false
    end

    it "returns true if token has expired" do
      expired_token_set = AtprotoAuth::State::TokenSet.new(
        access_token: access_token,
        token_type: token_type,
        expires_in: 1,
        refresh_token: refresh_token,
        scope: scope,
        sub: sub
      )
      # Force the token to appear expired
      expired_token_set.instance_variable_set(:@expires_at, Time.now - 10)
      _(expired_token_set.expired?).must_equal true
    end

    it "respects the buffer parameter for expiration check" do
      token_set_with_buffer = AtprotoAuth::State::TokenSet.new(
        access_token: access_token,
        token_type: token_type,
        expires_in: 10,
        refresh_token: refresh_token,
        scope: scope,
        sub: sub
      )
      _(token_set_with_buffer.expired?(15)).must_equal true
    end
  end
end
-----

test/atproto_auth/storage/key_builder_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"

describe AtprotoAuth::Storage::KeyBuilder do
  describe ".session_key" do
    it "builds valid session key" do
      assert_equal "atproto:session:123", AtprotoAuth::Storage::KeyBuilder.session_key("123")
    end
  end

  describe ".state_key" do
    it "builds valid state key" do
      assert_equal "atproto:state:xyz789", AtprotoAuth::Storage::KeyBuilder.state_key("xyz789")
    end
  end

  describe ".nonce_key" do
    it "builds valid nonce key" do
      assert_equal "atproto:nonce:example.com", AtprotoAuth::Storage::KeyBuilder.nonce_key("example.com")
    end
  end

  describe ".dpop_key" do
    it "builds valid dpop key" do
      assert_equal "atproto:dpop:client123", AtprotoAuth::Storage::KeyBuilder.dpop_key("client123")
    end
  end

  describe ".lock_key" do
    it "builds valid lock key" do
      assert_equal "atproto:lock:session:123",
                   AtprotoAuth::Storage::KeyBuilder.lock_key("session", "123")
    end
  end
end
-----

test/atproto_auth/storage/memory_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"
require_relative "storage_examples"

describe AtprotoAuth::Storage::Memory do
  let(:storage) { AtprotoAuth::Storage::Memory.new }

  include AtprotoAuth::Test::StorageExamples

  describe "memory-specific behavior" do
    it "cleans up expired keys automatically" do
      storage.set("atproto:test:short", "value", ttl: 1)
      storage.set("atproto:test:long", "value", ttl: 3600)

      assert_equal "value", storage.get("atproto:test:short")
      sleep 1.1 # Wait for expiration
      assert_nil storage.get("atproto:test:short")
      assert_equal "value", storage.get("atproto:test:long")
    end

    it "handles clear operation" do
      storage.set("atproto:test:1", "value1")
      storage.set("atproto:test:2", "value2")

      storage.clear

      assert_nil storage.get("atproto:test:1")
      assert_nil storage.get("atproto:test:2")
    end
  end
end
-----

test/atproto_auth/storage/redis_test.rb:
# frozen_string_literal: true

require_relative "../../test_helper"
require_relative "storage_examples"

describe AtprotoAuth::Storage::Redis do
  let(:redis) { Redis.new(url: ENV.fetch("REDIS_URL", "redis://localhost:6379")) }
  let(:storage) { AtprotoAuth::Storage::Redis.new(redis_client: redis) }

  # Include shared storage implementation tests
  include AtprotoAuth::Test::StorageExamples

  before do
    # Clear test keys before each test
    keys = redis.keys("atproto:*")
    redis.del(*keys) if keys.any?
  end

  describe "#initialize" do
    it "accepts a custom redis client" do
      custom_redis = Redis.new
      storage = AtprotoAuth::Storage::Redis.new(redis_client: custom_redis)
      _(storage.instance_variable_get(:@redis_client)).must_equal custom_redis
    end

    it "creates default redis client if none provided" do
      storage = AtprotoAuth::Storage::Redis.new
      _(storage.instance_variable_get(:@redis_client)).must_be_instance_of Redis
    end
  end

  describe "error handling" do
    it "wraps Redis connection errors" do
      redis.stub(:set, proc { raise Redis::ConnectionError }) do
        assert_raises(AtprotoAuth::Storage::Redis::RedisError) do
          storage.set("atproto:test:key", "value")
        end
      end
    end

    it "wraps Redis command errors" do
      redis.stub(:get, proc { raise Redis::CommandError }) do
        assert_raises(AtprotoAuth::Storage::Redis::RedisError) do
          storage.get("atproto:test:key")
        end
      end
    end
  end

  describe "TTL handling" do
    it "sets TTL on values" do
      storage.set("atproto:test:ttl", "value", ttl: 2)
      ttl = redis.ttl("atproto:test:ttl")
      assert_operator ttl, :>=, 1
      assert_operator ttl, :<=, 2
    end

    it "handles TTL in multi_set" do
      storage.multi_set({
                          "atproto:test:ttl1" => "value1",
                          "atproto:test:ttl2" => "value2"
                        }, ttl: 2)

      ["atproto:test:ttl1", "atproto:test:ttl2"].each do |key|
        ttl = redis.ttl(key)
        assert_operator ttl, :>=, 1
        assert_operator ttl, :<=, 2
      end
    end
  end

  describe "locking" do
    after do
      # Clean up any leftover locks
      redis.del("atproto:locks:atproto:test:lock")
    end

    it "creates lock with correct key prefix" do
      storage.acquire_lock("atproto:test:lock", ttl: 30)
      assert redis.exists?("atproto:locks:atproto:test:lock")
    end

    it "prevents duplicate lock acquisition" do
      storage.acquire_lock("atproto:test:lock", ttl: 30)
      refute storage.acquire_lock("atproto:test:lock", ttl: 30)
    end

    it "releases lock properly" do
      storage.acquire_lock("atproto:test:lock", ttl: 30)
      assert storage.release_lock("atproto:test:lock")
      refute redis.exists?("atproto:locks:atproto:test:lock")
    end

    it "ensures lock is released after block execution" do
      executed = false
      storage.with_lock("atproto:test:lock", ttl: 30) do
        executed = true
      end

      assert executed, "Block should have executed"
      refute redis.exists?("atproto:locks:atproto:test:lock")
    end

    it "ensures lock is released even if block raises error" do
      assert_raises(RuntimeError) do
        storage.with_lock("atproto:test:lock", ttl: 30) do
          raise "test error"
        end
      end

      refute redis.exists?("atproto:locks:atproto:test:lock")
    end

    it "releases lock if Redis connection fails during block execution" do
      redis.stub(:del, proc { raise Redis::ConnectionError }) do
        assert_raises(AtprotoAuth::Storage::Redis::RedisError) do
          storage.with_lock("atproto:test:lock", ttl: 30) { true }
        end
      end
    end
  end

  describe "atomic operations" do
    it "performs multi_set atomically" do
      storage.multi_set({
                          "atproto:test:1" => "value1",
                          "atproto:test:2" => "value2"
                        })

      # Both values should be set
      assert_equal "value1", storage.get("atproto:test:1")
      assert_equal "value2", storage.get("atproto:test:2")
    end

    it "rolls back multi_set if any operation fails" do
      # Simulate failure on second operation
      def storage.validate_key!(key)
        raise AtprotoAuth::Storage::StorageError if key == "atproto:test:2"

        super
      end

      assert_raises(AtprotoAuth::Storage::StorageError) do
        storage.multi_set({
                            "atproto:test:1" => "value1",
                            "atproto:test:2" => "value2"
                          })
      end

      # Value should not be set due to rollback
      assert_nil storage.get("atproto:test:1")
    end
  end
end
-----

test/atproto_auth/storage/storage_examples.rb:
# frozen_string_literal: true

module AtprotoAuth
  module Test
    # Shared examples for testing storage implementations
    # Include this module in storage implementation tests
    module StorageExamples
      def self.included(base)
        base.class_eval do
          describe "basic operations" do
            it "stores and retrieves values" do
              storage.set("atproto:test:key", "value")
              assert_equal "value", storage.get("atproto:test:key")
            end

            it "handles nil values" do
              storage.set("atproto:test:nil", nil)
              assert_nil storage.get("atproto:test:nil")
            end

            it "returns nil for missing keys" do
              assert_nil storage.get("atproto:test:missing")
            end

            it "deletes values" do
              storage.set("atproto:test:delete", "value")
              assert storage.delete("atproto:test:delete")
              assert_nil storage.get("atproto:test:delete")
            end

            it "checks existence" do
              storage.set("atproto:test:exists", "value")
              assert storage.exists?("atproto:test:exists")
              refute storage.exists?("atproto:test:missing")
            end
          end

          describe "key validation" do
            it "requires atproto: prefix" do
              assert_raises(AtprotoAuth::Storage::StorageError) do
                storage.set("invalid:key", "value")
              end
            end

            it "rejects nil keys" do
              assert_raises(AtprotoAuth::Storage::StorageError) do
                storage.set(nil, "value")
              end
            end

            it "rejects empty keys" do
              assert_raises(AtprotoAuth::Storage::StorageError) do
                storage.set("", "value")
              end
            end

            it "rejects non-string keys" do
              assert_raises(AtprotoAuth::Storage::StorageError) do
                storage.set(123, "value")
              end
            end
          end

          describe "TTL handling" do
            it "expires values after TTL" do
              storage.set("atproto:test:ttl", "value", ttl: 1)
              assert_equal "value", storage.get("atproto:test:ttl")
              sleep 1.1 # Wait for expiration
              assert_nil storage.get("atproto:test:ttl")
            end

            it "validates TTL values" do
              assert_raises(AtprotoAuth::Storage::StorageError) do
                storage.set("atproto:test:ttl", "value", ttl: -1)
              end

              assert_raises(AtprotoAuth::Storage::StorageError) do
                storage.set("atproto:test:ttl", "value", ttl: "invalid")
              end
            end

            it "handles nil TTL" do
              storage.set("atproto:test:ttl", "value", ttl: nil)
              assert_equal "value", storage.get("atproto:test:ttl")
            end
          end

          describe "batch operations" do
            it "handles multi-get" do
              storage.set("atproto:test:1", "value1")
              storage.set("atproto:test:2", "value2")

              result = storage.multi_get(["atproto:test:1", "atproto:test:2", "atproto:test:missing"])

              assert_equal(
                {
                  "atproto:test:1" => "value1",
                  "atproto:test:2" => "value2"
                },
                result
              )
            end

            it "handles multi-set" do
              values = {
                "atproto:test:1" => "value1",
                "atproto:test:2" => "value2"
              }

              assert storage.multi_set(values)
              assert_equal "value1", storage.get("atproto:test:1")
              assert_equal "value2", storage.get("atproto:test:2")
            end

            it "handles multi-set with TTL" do
              values = {
                "atproto:test:1" => "value1",
                "atproto:test:2" => "value2"
              }

              assert storage.multi_set(values, ttl: 1)
              assert_equal "value1", storage.get("atproto:test:1")
              assert_equal "value2", storage.get("atproto:test:2")

              sleep 1.1 # Wait for expiration
              assert_nil storage.get("atproto:test:1")
              assert_nil storage.get("atproto:test:2")
            end
          end

          describe "locking" do
            it "acquires and releases locks" do
              assert storage.acquire_lock("atproto:test:lock", ttl: 30)
              refute storage.acquire_lock("atproto:test:lock", ttl: 30)
              assert storage.release_lock("atproto:test:lock")
              assert storage.acquire_lock("atproto:test:lock", ttl: 30)
            end

            it "expires locks after TTL" do
              assert storage.acquire_lock("atproto:test:lock", ttl: 1)
              refute storage.acquire_lock("atproto:test:lock", ttl: 30)

              sleep 1.1 # Wait for expiration
              assert storage.acquire_lock("atproto:test:lock", ttl: 30)
            end

            it "executes blocks with locks" do
              result = storage.with_lock("atproto:test:lock", ttl: 30) do
                # Verify lock is held
                refute storage.acquire_lock("atproto:test:lock", ttl: 30)
                "success"
              end

              assert_equal "success", result
              # Verify lock is released
              assert storage.acquire_lock("atproto:test:lock", ttl: 30)
            end

            it "releases locks after block even if error raised" do
              assert_raises(RuntimeError) do
                storage.with_lock("atproto:test:lock", ttl: 30) do
                  raise "test error"
                end
              end

              # Verify lock is released
              assert storage.acquire_lock("atproto:test:lock", ttl: 30)
            end

            it "requires block for with_lock" do
              assert_raises(ArgumentError) do
                storage.with_lock("atproto:test:lock", ttl: 30)
              end
            end
          end

          describe "concurrency" do
            it "handles concurrent access to same key" do
              threads = 10.times.map do
                Thread.new do
                  storage.set("atproto:test:concurrent", "value")
                  storage.get("atproto:test:concurrent")
                  storage.delete("atproto:test:concurrent")
                end
              end

              threads.each(&:join)
              assert_nil storage.get("atproto:test:concurrent")
            end

            it "handles concurrent lock acquisition" do
              success_count = 0
              threads = 10.times.map do
                Thread.new do
                  if storage.acquire_lock("atproto:test:lock", ttl: 1)
                    success_count += 1
                    sleep 0.1
                    storage.release_lock("atproto:test:lock")
                  end
                end
              end

              threads.each(&:join)
              assert_equal 1, success_count
            end
          end
        end
      end
    end
  end
end
-----

test/atproto_auth/token/refresh_test.rb:
# frozen_string_literal: true

require "test_helper"

describe AtprotoAuth::Token::Refresh do
  before do
    AtprotoAuth.configure do |configuration|
      configuration.http_client = AtprotoAuth::HttpClient.new
    end

    client_metadata = AtprotoAuth::ClientMetadata.new(
      "client_id" => "https://example.com/metadata.json",
      "grant_types" => %w[authorization_code refresh_token],
      "response_types" => ["code"],
      "redirect_uris" => ["https://example.com/callback"],
      "scope" => "atproto offline_access",
      "dpop_bound_access_tokens" => true,
      "client_name" => "Example Client",
      "application_type" => "web"
    )

    # Set up a real session
    session = AtprotoAuth::State::Session.new(
      client_id: "mock_client",
      scope: "atproto",
      auth_server: AtprotoAuth::ServerMetadata::AuthorizationServer.new(
        "issuer" => "https://example.com",
        "token_endpoint" => "https://example.com/token",
        "authorization_endpoint" => "https://example.com/auth",
        "response_types_supported" => "code",
        "grant_types_supported" => %w[authorization_code refresh_token],
        "code_challenge_methods_supported" => "S256",
        "token_endpoint_auth_methods_supported" => %w[private_key_jwt none],
        "token_endpoint_auth_signing_alg_values_supported" => %w[ES256],
        "scopes_supported" => %w[atproto],
        "dpop_signing_alg_values_supported" => %w[ES256],
        "pushed_authorization_request_endpoint" => "https://example.com/pushed_auth",
        "authorization_response_iss_parameter_supported" => true,
        "require_pushed_authorization_requests" => true,
        "client_id_metadata_document_supported" => true
      )
    )
    token_set = AtprotoAuth::State::TokenSet.new(
      access_token: "existing_access_token",
      refresh_token: "mock_refresh_token",
      token_type: "DPoP",
      expires_in: 3600,
      scope: "atproto",
      sub: "subject_id"
    )
    session.tokens = token_set

    # Real DPoP client
    @dpop_client = AtprotoAuth::DPoP::Client.new

    # Stub HTTP request
    stub_request(:post, "https://example.com/token").to_return(
      status: 200,
      body: {
        access_token: "new_token",
        token_type: "DPoP",
        expires_in: 3600,
        scope: "atproto",
        sub: "subject_id"
      }.to_json,
      headers: { "Content-Type" => "application/json" }
    )

    # Token refresher
    @refresher = AtprotoAuth::Token::Refresh.new(
      client_metadata: client_metadata,
      session: session,
      dpop_client: @dpop_client,
      auth_server: session.auth_server
    )
  end

  it "refreshes the token and returns a new TokenSet" do
    token_set = @refresher.perform!

    assert_instance_of AtprotoAuth::State::TokenSet, token_set
    assert_equal "new_token", token_set.access_token
    assert_equal "atproto", token_set.scope
  end

  it "raises a Token::RefreshError after max retries are reached" do
    # Stub HTTP request to always fail
    stub_request(:post, "https://example.com/token").to_return(
      status: 500, # Internal Server Error
      body: { error: "server_error", error_description: "Something went wrong" }.to_json,
      headers: { "Content-Type" => "application/json" }
    )

    error = assert_raises(AtprotoAuth::Token::RefreshError) do
      @refresher.perform!
    end

    assert_match "Token refresh failed after 3 attempts", error.message
  end
end
-----

test/atproto_auth_test.rb:
# frozen_string_literal: true

require "test_helper"

describe AtprotoAuth do
  it "has a VERSION constant defined" do
    _(AtprotoAuth.const_defined?(:VERSION)).must_equal true
  end
end
-----

test/test_helper.rb:
# frozen_string_literal: true

$LOAD_PATH.unshift File.expand_path("../lib", __dir__)
require "atproto_auth"

require "minitest/autorun"
require "minitest/mock"
require "minitest/reporters"
require "mocha/minitest"
require "webmock/minitest"

# Set a consistent encryption key to use across all tests
ENV["ATPROTO_MASTER_KEY"] = Base64.strict_encode64("0" * 32)

Minitest::Reporters.use! Minitest::Reporters::SpecReporter.new unless ENV["RM_INFO"]

module Minitest
  module Assertions
    # Helper to check if a value is encrypted
    def assert_encrypted(value, msg = nil)
      assert value.is_a?(Hash), msg || "Expected encrypted hash format"
      assert_equal AtprotoAuth::Encryption::Service::VERSION, value["version"]
      assert value["iv"], "Missing IV"
      assert value["data"], "Missing encrypted data"
      assert value["tag"], "Missing auth tag"
    end
  end
end
-----

